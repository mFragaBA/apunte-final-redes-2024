<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unidad 5 - Ruteo - Apunte Final Teoria de las Comunicaciones 2024</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_0.html"><strong aria-hidden="true">1.</strong> Unidad 0 - Introducción, conceptos básicos</a></li><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">2.</strong> Unidad 1 - Nivel físico</a></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">3.</strong> Unidad 2 - Nivel de Enlace</a></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">4.</strong> Unidad 3 - Medios Compartidos</a></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">5.</strong> Unidad 4 - Nivel de Red</a></li><li class="chapter-item expanded "><a href="unidad_5.html" class="active"><strong aria-hidden="true">6.</strong> Unidad 5 - Ruteo</a></li><li class="chapter-item expanded "><a href="unidad_6.html"><strong aria-hidden="true">7.</strong> Unidad 6 - Nivel de Transporte</a></li><li class="chapter-item expanded "><a href="unidad_7.html"><strong aria-hidden="true">8.</strong> Unidad 7 - El problema de Congestión</a></li><li class="chapter-item expanded "><a href="unidad_8.html"><strong aria-hidden="true">9.</strong> Unidad 8 - Nivel de Aplicación</a></li><li class="chapter-item expanded "><a href="unidad_9.html"><strong aria-hidden="true">10.</strong> Unidad 9 - Seguridad</a></li><li class="chapter-item expanded "><a href="bibliografia.html"><strong aria-hidden="true">11.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Teoria de las Comunicaciones 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unidad-5---ruteo"><a class="header" href="#unidad-5---ruteo">Unidad 5 - Ruteo</a></h1>
<h2 id="internetworking"><a class="header" href="#internetworking">Internetworking</a></h2>
<p>En el 74' publican un paper de lo que se iba a a convertir en el protocolo
TCP/IP. Sin embargo, a este le faltaba una parte fundamental de lo que es hoy
en día que es el <strong>ruteo</strong>.</p>
<h3 id="sistemas-autónomos"><a class="header" href="#sistemas-autónomos">Sistemas autónomos</a></h3>
<p>Uno podría decir que internet es la interconexión entre <strong>sistemas autónomos</strong>, que
los definimos como un conjunto de routers administrados por la misma entidad.
Por ejemplo, la red de algún ministerio, la de la facultad, la de tu trabajo,
etc.</p>
<ul>
<li>Tengo 2 tipos de ruteo:
<ul>
<li>interno(IGP): lo que se mueve dentro del sistema autónomo</li>
<li>externo(EGP): lo que va hacia otro sistema autónomo
<ul>
<li>hoy en día el protocolo estandarizado para esto es <strong>BGP</strong> (Border
Gateway Protocol)</li>
</ul>
</li>
</ul>
</li>
<li>A priori lo que pasa adentro de un sistema autónomo queda dentro del sistema
autónomo. Los otros sistemas autónomos no conocen esos detalles.
<ul>
<li>Dicho eso, hay 2 protocolos dentro de los más usados
<ul>
<li><strong>RIP</strong></li>
<li><strong>OSPF</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Nosotros vamos a priorizar protocolos de ruteo interno. De ruteo externo más
que nada hablamos de las políticas.</p>
<div id="admonition-analizando-la-red" class="admonition admonish-info">
<div class="admonition-title">
<p>Analizando la red</p>
<p><a class="admonition-anchor-link" href="#admonition-analizando-la-red"></a></p>
</div>
<div>
<p>Si pensamos en la internet como la interconexión de sistemas autónomos, podemos también querer analizar el grafo subyacente de esas interconexiones. Pero esa no es la única forma de analizarlo. Podemos armar:</p>
<ul>
<li>grafo de routers</li>
<li>grafo de Web servers</li>
<li>grafo de Name servers</li>
<li>grafo P2P</li>
<li>grafo CDN</li>
<li>etc.</li>
</ul>
</div>
</div>
<h3 id="ruteo"><a class="header" href="#ruteo">Ruteo</a></h3>
<p>En última instancia, nuestro problema se reduce a poder mandar los
paquetes/frames de una punta a la otra. Tenemos 2 procesos:</p>
<ul>
<li>Forwarding (esto es similar a lo que vimos con los learning bridges) consiste
en <strong>elegir una puerta de salida</strong> mirando la dirección destino y tablas de
ruteo.</li>
<li>Ruteo: este es el proceso por el que <strong>construimos las tablas de ruteo</strong>
<ul>
<li>Es un problema de grafos</li>
<li>Vemos a la red como un conjunto de nodos y arcos pesados</li>
</ul>
</li>
</ul>
<p>Además hay 2 tipos de ruteo:</p>
<ul>
<li>Estático: lo configuro una vez y listo</li>
<li>Dinámico: se configura autónomamente y se adapta a cambios en la topología de
la red.</li>
</ul>
<div id="admonition-ruteo-en-modelo-osi" class="admonition admonish-info">
<div class="admonition-title">
<p>Ruteo en modelo OSI</p>
<p><a class="admonition-anchor-link" href="#admonition-ruteo-en-modelo-osi"></a></p>
</div>
<div>
<ul>
<li>Llamamos <strong>PDU</strong> (Protocol Data Unit)
<ul>
<li>A nivel 4 es un segmento</li>
<li>A nivel 3 es un datagrama</li>
<li>A nivel 2 es un frame</li>
<li>el PDU es la unidad de datos relevante para cada capa. Esto contiene no
sólo la data que viene de la capa superior/inferior, si no también el
encapsulado hecho por la capa</li>
</ul>
</li>
<li>Al nivel 3 lo conforman un par de protocolos:
<ul>
<li>Protocolos de ruteo
<ul>
<li>permite elegir caminos para los datagramas</li>
</ul>
</li>
<li>Protocolo de IP
<ul>
<li>describe las convenciones de direccionamiento, el formato de los
datagramas y las convenciones sobre el manejo de paquetes</li>
</ul>
</li>
<li>Protocolo ICMP
<ul>
<li>permite reporte de errores, mandar señales entre routers entre otras
cosas</li>
<li>por ejemplo, las aplicacioneas <em>ping</em> y <em>traceroute</em> están basadas en
el envío de paquetes ICMP. Ping manda un mensaje de <em>ICMP echo
request</em> y cuando le llega al destino responde. Se repite varias
veces y se sacan métricas. Traceroute arranca con TLL = 0 y envía el
echo request y va aumentando el TTL de a 1, entonces cada request va
encontrando un hop nuevo cada vez.</li>
<li><a href="https://www.cloudflare.com/en-gb/learning/ddos/glossary/internet-control-message-protocol-icmp/">offtopic</a>:
explicación breve de cloudfare sobre qué es el protocolo ICMP y
algunos ataques conocidos <img src="./img/traceroute.gif#center" alt="" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./img/routing_osi.png" alt="" /></p>
</div>
</div>
<h3 id="tablas-de-ruteo-y-de-forwarding"><a class="header" href="#tablas-de-ruteo-y-de-forwarding">Tablas de Ruteo y de forwarding</a></h3>
<ul>
<li>La tabla de enrutamiento dice a qué "next hop" mandar el paquete (tiene la
info lógica)
<ul>
<li>además como next hop puedo tener un default gateway (por ejemplo, en gral
el router de nuestra casa sigue la regla de que todo lo que no esté
dentro de la red sale al default gateway)</li>
<li>si el dstAddr pertenece a la misma red que el router entonces ya puede
mandar el paquete por la interface correspondiente a esa red.</li>
</ul>
</li>
<li>La tabla de forwarding dice cómo mandar el paquete a un next hop (tiene la
info física)
<ul>
<li>cómo se le asigna inicialmente una ip si recién me conecto? DHCP (lo
vemos más adelante), que te provee de una IP privada para la red local.</li>
</ul>
</li>
<li>el mapeo de dirección IP -&gt; dirección física se conoce mediante ARP
(Adress Resolution Protocol)</li>
</ul>
<h4 id="arp"><a class="header" href="#arp">ARP</a></h4>
<p><img src="./img/routing_forwarding_tables.png" alt="" /></p>
<ul>
<li>Cada router mantiene una tabla (ARP table o ARP cache)
que mappea addrIP -&gt; addrFísica</li>
<li>Aprox. cada 15 minutos se reinicia dicha tabla</li>
<li>Algoritmo: si al momento de mandar no tiene el mapeo
IP -&gt; MAC entonces broadcastea un ARP query. La query
tiene la dirección IP. El host que recibe la query y
matchea su dirección ip con la de la query, manda una
respuesta que contiene la MAC.</li>
<li>También en el ARP query se incluye la dirección del
que emite la request lo cual hace que todos los otros
hosts y routers que lo reciban ya conozcan la
dirección física que le corresponde a la IP que hizo
la query.</li>
<li>Al igual que pasaba con las tablas de los learning
bridges, si ya estaba en la tabla se resetea el tiempo
límite para sacar la row de dicha tabla.</li>
</ul>
<h4 id="dhcp"><a class="header" href="#dhcp">DHCP</a></h4>
<ul>
<li>Es un método de configuración dinámica para asignar IPs a los distintos nodos
de una red.</li>
<li>El detalle principal es la existencia de al menos un servidor DHCP.
<ul>
<li>el servidor mantiene una pool de direcciones disponibles que va a ir
administrando de forma automática.</li>
</ul>
</li>
<li>Además, dado que la idea es minimizar la cantidad de configuración a realizar
también se provee un mecanismo para que los hosts encuentren y se puedan
comunicar con el servidor DHCP.
<ul>
<li>Envían un mensaje <em>DHCPDISCOVER</em> a la dirección de ip de broadcast</li>
<li>El servidor DHCP eventualmente recibe el paquete y responde</li>
</ul>
</li>
<li>Además, no siempre contamos con un servidor DHCP por red (ni siempre es
deseable), por lo que también se cuenta con <em>relay agents</em> que su función es
mantener la dirección IP del servidor DHCP. El relay agent se encarga de
mandarle al servidor DHCP los mensajes <em>DHCPDISCOVER</em> que recibe.</li>
<li>El protocolo también admite la posibilidad de que la ip se otorgue por un
tiempo determinado. Esto permite olvidarnos de detectar nodos caídos o que se
desconectan y facilitan el manejo y la liberación de recursos para el
servidor.
<ul>
<li>Los hosts tienen la posibilidad de "renovar" dichas direcciones IP</li>
</ul>
</li>
</ul>
<h3 id="algoritmos-de-ruteo-interno"><a class="header" href="#algoritmos-de-ruteo-interno">Algoritmos de ruteo interno</a></h3>
<p>Se clasifican en:</p>
<ul>
<li><strong>Distance vector</strong></li>
<li><strong>Link state</strong></li>
</ul>
<p>Y estos dan lugar a los protocolos de ruteo (RIP y OSPF)</p>
<div class="table-wrapper"><table><thead><tr><th>Cada Router</th><th>DISTANCE-VECTOR</th><th>LINK-STATE</th></tr></thead><tbody>
<tr><td>Qué informa?</td><td>Toda su tabla de ruteo</td><td>Sólo el estado de sus enlaces directos</td></tr>
<tr><td>A quién le pasa la info?</td><td>Sólo a sus vecinos</td><td>A toda la red (hace flooding)</td></tr>
<tr><td>Algoritmo utilizado</td><td>Bellman-Ford distribuido</td><td>Dijkstra</td></tr>
<tr><td>Datos utilizados</td><td>Info de sus vecinos</td><td>Estado de enlaces de cada nodo</td></tr>
<tr><td>Estructuras de datos</td><td>Tabla de distancias y Tabla de ruteo</td><td>Tabla de Estado de Enlaces y tabla de ruteo</td></tr>
<tr><td>Características</td><td>Ciclos de Ruteo</td><td>Visión consistente de la red</td></tr>
<tr><td></td><td>Gran variedad de algoritmos(Merlin-Segall, Jaffe-Moss, entre otros.)</td><td>Algoritmo básico único</td></tr>
<tr><td></td><td>Cálculo distribuido</td><td>Cálculo centralizado</td></tr>
<tr><td></td><td></td><td>Mucho uso de CPU y Memoria</td></tr>
<tr><td>Protocolo de Internet</td><td>RIP</td><td>OSPF</td></tr>
</tbody></table>
</div><div id="admonition-pequeño-recuerdo-de-bellman-ford-vs-dijstra" class="admonition admonish-info">
<div class="admonition-title">
<p>Pequeño recuerdo de Bellman-Ford vs Dijstra</p>
<p><a class="admonition-anchor-link" href="#admonition-pequeño-recuerdo-de-bellman-ford-vs-dijstra"></a></p>
</div>
<div>
<p>Ambos algoritmos permiten construir un arbol de caminos mínimos con raíz en un
nodo <em>v</em></p>
<h4 id="bellman-ford"><a class="header" href="#bellman-ford">Bellman-Ford</a></h4>
<p>Idea: construyo un arbol de caminos mínimos parcial \(T_k\) donde
\(T_k[i]\) te dice la distancia del camino mínimo del nodo \(i\) a la raiz
\(v\) usando a lo sumo \(k-1\) ejes, y cuál es su antecesor en ese camino.
Eventualmente el \(T_{|V|-1}\) tiene lo que quiero.</p>
<h4 id="dijkstra"><a class="header" href="#dijkstra">Dijkstra</a></h4>
<p>Idea: es el algoritmo de prim de AGM pero cambiamos la función que se usa para
definir qué nodo agregar y con qué arista. Elijo aquél nodo cuya distancia a la
raíz se minimice con la arista agregada. O sea si tengo el subárbol generador
\(T_k\) enraizado en \(v\), agregamos el nodo \(w\) y la arista \((u,w)\)
que minimizan \(T_k[u] + d(u, w)\) para cada arista candidata.</p>
</div>
</div>
<h3 id="rip-vector-de-distancia"><a class="header" href="#rip-vector-de-distancia">RIP (Vector de Distancia)</a></h3>
<ul>
<li>Cada nodo mantiene una tabla de distancias con tuplas de <code>(Dst, Cost, NextHop)</code>
<ul>
<li>Tiene la mejor distancia conocida a cada destino, y qué salida se usa
para llegar ahí</li>
</ul>
</li>
<li>Intercambia mensajes <strong>sólo con los vecinos directos</strong>
<ul>
<li>Esto ocurre periódicamente (cada ciertos segundos) o cuando su tabla
cambia por algún trigger.</li>
</ul>
</li>
<li>Cada actualización es una lista de pares <code>(Destination, Cost)</code></li>
<li>Se modifica la tabla si se recibe una <strong>mejor ruta</strong>
<ul>
<li>Tiene menor costo</li>
<li>Llegó desde el next-hop de ese destino</li>
</ul>
</li>
<li>Al igual que antes, tienen un timeout bajo el cuál se limpian las entradas de la tabla</li>
<li>Por qué se eligió Bellman-Ford distribuido en lugar de Dijkstra? Porque como
mencionamos, dijkstra consumía más cpu y memoria y al principio no había
tanto hardware que lo soporte (o se volvía muy caro).</li>
</ul>
<p>Algoritmo:</p>
<pre><code class="language-python">def receive_table(self, router_id, routing_table):
    for (destination, cost, next_hop) in self.routing_table:
        if destination == self.router_id: continue

        if routing_table[destination] + self.routing_table[router_id] &lt; cost:
            self.routing_table[destination] = (routing_table[destination] + self.routing_table[router_id], router_id)
</code></pre>
<p>En gral el costo lo medimos en nro. de saltos y listo. Al principio que tengo
nodos a los que no sé cómo llegar, los inicializo en infinito.</p>
<h4 id="qué-pasa-cuando-un-enlace-falla"><a class="header" href="#qué-pasa-cuando-un-enlace-falla">Qué pasa cuando un enlace falla?</a></h4>
<ul>
<li>caso feliz
<ul>
<li>falla el enlace de F a G. F lo detecta y setea su distancia a G a
infinito, y avisa a sus vecinos.</li>
<li>A se entera de eso y también setea su distancia a infinito.</li>
<li>A recibe una actualización de C con un camino a G en 2 saltos. Actualiza
su tabla para tener distancia de 3 saltos a G y manda la info a los
vecinos.</li>
<li>F recibe la actualización y setea su distancia a G en 4 saltos usando A.
<img src="./img/rip_happy_path.png" alt="" /></li>
</ul>
</li>
<li>caso triste (inestable, <strong>conteo a infinito</strong>)
<ul>
<li>falla el enlace de A a E. A le comunica a B y a C una distancia infinito
a E.</li>
<li>Tanto B como C antes de recibir el update de A comunican que llegan a E con distancia 2</li>
<li>Luego se les actualiza su distancia a infinito</li>
<li>Luego B decide que llega en 3 saltos a E a través de C y le avisa a A</li>
<li>A decide que llega en 4 saltos a E a través de B y le avisa a C</li>
<li>C decide que llega en 5 saltos a E a través de A</li>
<li>B decide que llega en 6 saltos a E a través de C</li>
<li>y así sucesivamente...</li>
<li>Esto está muy condicionado al timing en el que se reciben los mensajes.</li>
</ul>
</li>
</ul>
<p>Cómo lo resuelvo? Facilito: uso la heurística de que costo &gt; 16 lo setea como infinito</p>
<h4 id="formato-del-paquete"><a class="header" href="#formato-del-paquete">Formato del paquete</a></h4>
<ul>
<li>Comando</li>
<li>Version</li>
<li>Y una lista una atraz de la otra que contienen
<ul>
<li>red</li>
<li>tags</li>
<li>prefijo de red</li>
<li>mascara de red</li>
<li>distancia a la red</li>
</ul>
</li>
</ul>
<p><img src="./img/rip_packet.png#center" alt="" /></p>
<div id="admonition-sobre-qué-capa-corre-rip" class="admonition admonish-info">
<div class="admonition-title">
<p>Sobre qué capa corre RIP?</p>
<p><a class="admonition-anchor-link" href="#admonition-sobre-qué-capa-corre-rip"></a></p>
</div>
<div>
<p>Uno podría pensar que RIP corre encapsulado sobre capa 3. Sin embargo, su
implementación es a nivel de aplicación y corre como un daemon usando UDP. Las
tablas de ruteo siguen en capa 3 pero el algoritmo y armado de las tablas
corren como una aplicación más.</p>
<p><img src="./img/rip_daemon.png#center" alt="" /></p>
</div>
</div>
<h3 id="ospf---open-shortest-path-first-link-state"><a class="header" href="#ospf---open-shortest-path-first-link-state">OSPF - Open Shortest Path First (Link State)</a></h3>
<ul>
<li>Todos los nodos tienen la misma info
<ul>
<li>O sea todos conocen la topología de la red gracias al mecanismo de
flooding (el flooding se hace dentro del sistema autónomo)</li>
</ul>
</li>
<li>Calculo el camino mínimo usando Dijkstra (forward search)</li>
<li>Algoritmo:
<ul>
<li>Descubro vecinos y sus direcciones de red</li>
<li>Mido el costo para cada vecino</li>
<li>Construyo un paquete con lo aprendido de los vecinos (Link State Packet,
<strong>LSP</strong>)
<ul>
<li>ID del router que lo creó</li>
<li>Costo del enlace a cada uno de sus vecinos</li>
<li>Número de secuencia (SEQNO)</li>
<li>TTL</li>
</ul>
</li>
<li>Mando el paquete a <strong>todos los demás routers</strong></li>
<li>Aplica Dijkstra y calcula la ruta más corta a todos los nodos</li>
</ul>
</li>
<li>Flooding: Cada router
<ul>
<li>Almacena el LSP más reciente de cada nodo</li>
<li>Decremena TTL
<ul>
<li>Descarta si TTL = 0</li>
<li>Manda un LSP ACK (por eso la inundación es confiable)
<ul>
<li>El protocolo reenvía los LSP que recibió a todos los que no le
mandaron el ACK (y tampoco el que le había mandado el paquete)</li>
</ul>
</li>
</ul>
</li>
<li>Reenvía LSP a todos los nodos menos el que envió el paquete recién
recibido</li>
<li>Genera LSP periodicamente e incrementa el SEQNO</li>
<li>Cuando se reinicia setea <code>SEQNO = 0</code></li>
</ul>
</li>
<li>En la práctica el algoritmo se maneja on the fly
<ul>
<li>Los registos son <code>(dstAddr, cost, next_hop)</code></li>
<li>Para eso se manejan dos listas:
<ul>
<li>tentativo</li>
<li>confirmado</li>
<li>En cada ciclo agrego entradas a la lista de tentativos, y el de menor
costo de todos los tentativos se pasa a confirmado. Una vez agregado
se recomputan los de la lista de tentativos.</li>
</ul>
</li>
</ul>
</li>
<li>A diferencia de RIP, OSPF está implementado sobre IP directamente.</li>
</ul>
<h4 id="ospf-jerárquico"><a class="header" href="#ospf-jerárquico">OSPF Jerárquico</a></h4>
<ul>
<li>Puedo dividir un sistema autónomo definiendo
<ul>
<li>varias "áreas" (pueden tener routers adentro)</li>
<li>un troncal de routers (un backbone)</li>
<li>routers de frontera de área que conectan el área con los troncales</li>
<li>un router frontera que sale hacia otro sistema autónomo</li>
</ul>
</li>
<li>El flooding se hace dentro de cada área, entonces saturo menos la red con
mensajes y hago más escalable a OSPF respecto de RIP</li>
</ul>
<h4 id="mensajes-de-ospf"><a class="header" href="#mensajes-de-ospf">Mensajes de OSPF</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Tipo de Mensaje</th><th>Descripción</th></tr></thead><tbody>
<tr><td>Hello</td><td>Sirve para descubrir los vecinos</td></tr>
<tr><td>Link State Update</td><td>Proporciona los costos del emisor a sus vecinos</td></tr>
<tr><td>Link State ACK</td><td>Confirma la recepción del update</td></tr>
<tr><td>Database description</td><td>Anuncia qué actualizaciones tiene el emisor</td></tr>
<tr><td>Link state request</td><td>Solicita información del socio</td></tr>
</tbody></table>
</div><div id="admonition-pregunta-de-final-alert" class="admonition admonish-warning">
<div class="admonition-title">
<p>PREGUNTA DE FINAL ALERT</p>
<p><a class="admonition-anchor-link" href="#admonition-pregunta-de-final-alert"></a></p>
</div>
<div>
<p>Por qué decimos que OSPF realiza una inundación <strong>confiable</strong>?</p>
<ul>
<li>Porque el flooding se hace a todos los nodos del sistema autónomo</li>
<li>Y de cada nodo recibo el ack para asegurarme de que le llegó</li>
</ul>
</div>
</div>
<h4 id="paquete-de-ospf"><a class="header" href="#paquete-de-ospf">Paquete de OSPF</a></h4>
<p><img src="./img/ospf_header.png" alt="" /></p>
<p>Estoy mandando un paquete IP con el mismo formato que vimos en la unidad
anterior, en donde el campo de protocolo lleva el valor 89 para indicar que es
un paquete de OSPF. Además se usan algunos de los campos opcionales.</p>
<h3 id="bgp---ruteo-interdominio"><a class="header" href="#bgp---ruteo-interdominio">BGP - Ruteo Interdominio</a></h3>
<p>Generalidades:</p>
<ul>
<li>Diseñado para una red estructurada como árbol.</li>
<li>Prioriza <strong>alcanzar nodos</strong>, no optimiza rutas.</li>
</ul>
<p>Y para lograrlo usa los mensajes:</p>
<ul>
<li>Adequisición de vecinos: Pide a un router vecino ser su par, y los routers pares intercambian información de alcance.</li>
<li>Alcance de vecinos: mediante mensajes de <em>HELLO</em> y <em>ACK</em> chequean periódicamente que sus vecinos sigan siendo alcanzables.</li>
<li>Actualización de rutas: los routers intercambian periódicamente sus tablas de
ruteo.</li>
</ul>
<p>BGP resuelve el problema de evitar que los sistemas autónomos tengan que compartir info de alcanzabilidad entre ellos, manteniendo:</p>
<ul>
<li>cuáles rangos de direcciones IP se alcanzan en cada AS</li>
<li>por qué ruta se puede llegar de un AS <em>A</em> a un AS <em>B</em></li>
</ul>
<p><img src="./img/bgp.png" alt="" /></p>
<p>En este ejemplo podemos suponer que cada regional provider es un proveedor
(léase telecom, telefónica, etc.). Para llegar a USA, cómo hace Telecom? Va a
tener que pasar por el backbone, supongamos que es At&amp;t, que es un proveedor de
tier 1. Entonces, ese proveedor de tier 1 te va a cobrar por el servicio (que
sería publicar las rutas al resto del mundo, y además por cuánta data pasás).</p>
<p>Ahora, originalmente (~año 2000) el tráfico de acá se tenía que ir hasta USA
para volver a los servidores de acá. Se puede evitar eso? Surgen los NAP
(Network Access Point) o IX (Internet eXchanges).</p>
<ul>
<li>En Argentina tenemos la CABASE (Cámara Argentina de Internet)</li>
<li>Tienen uno o varios routers gigantes que interconectan varios ISPs locales.</li>
<li>2 beneficios, menos RTT y menor costo para el tráfico internacional</li>
</ul>
<p>Hoy en día, el tráfico internacional es bastante bajo porque el contenido está
almacenado localmente bajo CDNs (Content Distribution Networks).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="unidad_4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="unidad_6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="unidad_4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="unidad_6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
