<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unidad 3 - Medios Compartidos - Apunte Final Teoria de las Comunicaciones 2024</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_0.html"><strong aria-hidden="true">1.</strong> Unidad 0 - Introducción, conceptos básicos</a></li><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">2.</strong> Unidad 1 - Nivel físico</a></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">3.</strong> Unidad 2 - Nivel de Enlace</a></li><li class="chapter-item expanded "><a href="unidad_3.html" class="active"><strong aria-hidden="true">4.</strong> Unidad 3 - Medios Compartidos</a></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">5.</strong> Unidad 4 - Nivel de Red</a></li><li class="chapter-item expanded "><a href="unidad_5.html"><strong aria-hidden="true">6.</strong> Unidad 5 - Ruteo</a></li><li class="chapter-item expanded "><a href="unidad_6.html"><strong aria-hidden="true">7.</strong> Unidad 6 - Nivel de Transporte</a></li><li class="chapter-item expanded "><a href="unidad_7.html"><strong aria-hidden="true">8.</strong> Unidad 7 - El problema de Congestión</a></li><li class="chapter-item expanded "><a href="unidad_8.html"><strong aria-hidden="true">9.</strong> Unidad 8 - Nivel de Aplicación</a></li><li class="chapter-item expanded "><a href="unidad_9.html"><strong aria-hidden="true">10.</strong> Unidad 9 - Seguridad</a></li><li class="chapter-item expanded "><a href="bibliografia.html"><strong aria-hidden="true">11.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Teoria de las Comunicaciones 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unidad-3---medios-compartidos"><a class="header" href="#unidad-3---medios-compartidos">Unidad 3 - Medios Compartidos</a></h1>
<p>Antes vimos que se podía compartir un canal de transmisión mediante técnicas
como la multiplexación por tiempo o por frecuencia. Esas técnicas lo que
permitían era lograr que varios nodos utilicen el medio "de forma
independiente", o sea que la transmisión de un dispositivo no interfiera con la
de otro.</p>
<p>Ahora vamos a ver otro approach, que es sugerido y generalmente utilizado para
ethernet y en el protocolo de wifi (802.11). La idea es permitir que todos los
dispositivos usen el mismo canal para transferir, y si más adelante hay un
problema (ej 2 quieren transmitir al mismo tiempo) ahí se ve cómo se resuelve.</p>
<p>Y por supuesto se va a buscar minimizar la cantidad de intentos que tiene que
hacer un dispositivo para poder hacer el envio de paquetes deseado y asegurar
fairness.</p>
<p>La tecnología que usa Ethernet y otras redes inalámbricas (802.11), lleva el
nombre de Carrier Sense, Multiple Access with Collision Detect (CSMA/CD). Es un
protocolo que permite que un conjunto de nodos manden mensajes a través de un
enlace compartido.</p>
<ul>
<li>El <strong>Carrier Sense</strong> viene por el hecho de que todos los nodos pueden
distinguir en todo momento si un canal está libre o en uso.</li>
<li>Por otro lado, el <strong>Collision Detect</strong> viene por el hecho de que el emisor a
medida que transmite sensa el canal y puede darse cuenta de si hubo una
colisión en la transmisión con otro nodo.</li>
</ul>
<p>La realidad es que hoy en día la mayoría de las conexiones cableadas son punto
a punto (o sea el enlace es propio de cada par de nodos). Y la parte de
multiplexación la resuelven los switches. Es por eso que hoy en día no está tan
presente el protocolo... redes cableadas.</p>
<p>Por otro lado las redes inalámbricas hoy en día son la norma en muchos entornos
con lo cual el uso de CSMA/CD retoma relevancia.</p>
<p><img src="./img/csma_cd_meme.png" alt="" /></p>
<div id="admonition-dominio-de-colisión" class="admonition admonish-info">
<div class="admonition-title">
<p>Dominio de Colisión</p>
<p><a class="admonition-anchor-link" href="#admonition-dominio-de-colisión"></a></p>
</div>
<div>
<p>Llamamos <strong>Dominio de Colisión</strong> al conjunto de los nodos que pueden generar
una colisión en el medio al intentar transmitir (no están incluidas los nodos
separados por medio de un switch).</p>
</div>
</div>
<h2 id="csmacd"><a class="header" href="#csmacd">CSMA/CD</a></h2>
<p>Vamos a ver el caso de acceso múltiple en cable ethernet ya que si bien es algo
anecdótico hoy en día, los mismos principios se pueden aplicar a nuevas
tecnologías.</p>
<p>Para empezar hablemos un toque de Ethernet:</p>
<ul>
<li>Admite tramos de hasta 500m (no más para evitar atenuación de la señal).</li>
<li>Admite máximo hasta 4 repetidores</li>
<li>Requiere como mínimo 2,5 metros entre host y host.</li>
<li>Las transmisiones son broadcasteadas a lo largo del cable (y a través de
repetidores)</li>
</ul>
<p>Además, un frame de Ethernet contiene los siguientes campos (segun el estándar 802.3):</p>
<p><img src="./img/eth_frame.png" alt="" /></p>
<ul>
<li>Primero tiene un preámbulo de 64 bits, es una secuencia de 0's y 1's
alternada que le permite al receptor sincronizarse con la señal.</li>
<li>Después le siguen las direcciones de destino y fuente respectivamente que son
direcciones de 48 bits.
<ul>
<li>las direcciones son "únicas" y vienen grabadas en la rom de los
adaptadores de red</li>
<li>El adaptador de red sensa el canal y si ve un frame cuyo campo de
destinatario es su dirección entonces le deriva el frame al host. Hace lo
mismo si el frame tiene la dirección de broadcast.</li>
</ul>
</li>
<li>Después sigue el campo del tipo, que indica a cuál protocolo de más alto
nivel se le enviaría el frame.</li>
<li>Luego el body del frame tiene la data en si a enviar. Un detalle no menor es
que un frame puede contener hasta 1500 bytes de datos, y tiene que tener por
lo menos 46 bytes de datos (esto último es necesario para tener tiempo
suficiente de detectar una colisión) por lo que en caso de no tener
suficientes datos se le agrega algo de padding.</li>
<li>Por último un campo CRC para chequeo de errores</li>
</ul>
<p>Un pequeño detalle es que para el host el frame de ethernet en realidad no
tiene ni el preámbulo ni el CRC, el adaptador de red es el que se encarga de
agregar esos campos extra.</p>
<p>El algoritmo que sigue un transmisor que implementa CSMA/CD se puede resumir con el siguiente diagrama de estados:</p>
<p><img src="./img/csma_cd_state_diagram.png" alt="" /></p>
<ul>
<li>El transmisor siempre que le llega un frame nuevo va a intentar transmitir
<ul>
<li>Si el canal está libre transmite de una</li>
<li>Si el canal está ocupado, espera a que se libere
<ul>
<li>Ni bien se libera, el transmisor va a intentar enviar</li>
</ul>
</li>
</ul>
</li>
<li>Si está transmitiendo, pueden pasar 1 de 2 cosas:
<ul>
<li>Es el único dispositivo usando el canal y el frame se envía correctamente
y sin problemas</li>
<li>Mientras está enviando, otro dispositivo también decide enviar un frame,
generando lo que se conoce como una <strong>colisión</strong>. Para eso el transmisor
sensa el medio y si detecta un voltage anormal entonces eso es a causa de
la colisión
<ul>
<li>Cuando detecta una colisión frena la transmisión actual y envía una
<strong>secuencia de jamming</strong> de 32 bits (por lo general es una tira de
1's y listo). El objetivo de dicha secuencia es hacer que el receptor
deje de escuchar la señal.
<ul>
<li>Eventualmente el otro emisor también va a detectar la colisión y
va a enviar su propia secuencia de jamming.</li>
</ul>
</li>
<li>Una vez que se detecta la colisión y se envía la secuencia de
jamming, se aplica una política de <strong>exponential backoff</strong>. Eso es
esperar un cierto tiempo antes de enviar. Si se vuelve a dar una
colisión, esperar el doble y así hasta que se haga efectiva o se
supere un límite predefinido (en general es de 16 intentos), en cuyo
caso el adaptador avisa al host que la transmisión falló.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div id="admonition-exponential-backoff" class="admonition admonish-info">
<div class="admonition-title">
<p>Exponential Backoff</p>
<p><a class="admonition-anchor-link" href="#admonition-exponential-backoff"></a></p>
</div>
<div>
<p>Para ser un poco más específico, la idea en el exponential backoff es dividir
el tiempo en slots entre 0 y \(2^k - 1\), siendo \(k\) la cantidad de
intentos. Se elige uno de los slots al azar y eso representa la cantidad de
slots que se espera. Un slot representa 51,2 \(\mu\)s que es el tiempo
necesario para transferir el frame más chico.</p>
</div>
</div>
<p>Ahora que conocemos el algoritmo, tiene más sentido el motivo por el cuál
necesitamos tener al menos 46 bytes de datos a enviar. Esto es porque incluso
en el caso en el que estén los dos hosts lo más alejados posible (2500 metros
usando 4 repetidores), el Round Trip Delay es de al rededor de 51,2 \(\mu\)s
que en una conexión de 10Mbps equivale a 512 bits. De esta forma, si nuestra
frame tiene al menos 512 bits si o si uno de los dos emisores va a detectar la
colisión antes de terminar de enviar su frame.</p>
<div id="admonition-transmisores-p-persistentes" class="admonition admonish-info">
<div class="admonition-title">
<p>Transmisores <em>p</em>-persistentes</p>
<p><a class="admonition-anchor-link" href="#admonition-transmisores-p-persistentes"></a></p>
</div>
<div>
<p>Ethernet se dice que es un protocolo 1-persistente porque siempre que sensa el
medio y está libre va a intentar enviar. Este es un caso particular de lo que
se conoce como transmisores <em>p</em>-persistentes, en donde se transmite con
probabilidad <em>p</em> una vez que se libera el medio.</p>
</div>
</div>
<p>Una última observación es que en este algoritmo se contempla que sólo se puede
leer <em>o</em> escribir en el canal, pero no los 2 al mismo tiempo. Eso se conoce
como un algoritmo de <strong>half-duplex</strong>. No confundir esto con la clasificación de
canales. El canal puede ser full duplex (se puede escuchar y enviar al mismo
tiempo) mientras que el algoritmo es half duplex.</p>
<p>Recomiendo también pegarle una chusmeada a <a href="https://cs.newpaltz.edu/~easwarac/CCN/Week13/CSMA.pdf">esta explicación</a> de CSMA/CD.</p>
<h3 id="midiendo-performance-de-csma"><a class="header" href="#midiendo-performance-de-csma">Midiendo performance de CSMA</a></h3>
<p>Sean \(S\) la <strong>carga ofrecida</strong> (nro de intentos de transmisión por unidad
de tiempo, o sea cuánto tengo que usar del medio para transmitir) y \(G\) el
<strong>goodput</strong> (proporción de transmisiones exitosas por unidad de tiempo),
entonces:</p>
<p>$$
S = G * (1 - P_{colision})
$$</p>
<p>Podemos graficar la relación entre la carga, el goodput y la variante de CSMA:</p>
<p><img src="./img/link_performance.png#center" alt="" /></p>
<ul>
<li>Aloha es otro protocolo que consiste en lo que vimos antes. Enviar un mensaje
y si no me llega un ACK de dicho mensaje re-enviar. (esto no descarta
totalmente ese mecanismo para asegurar confiabilidad y control de errores
porque como verems más adelante si se usa en protocolos de más alto nivel)
<ul>
<li>Slotted aloha es lo mismo pero la emisión se da en "slots discretos"</li>
</ul>
</li>
<li>CSMA es fácil de implementar pero tiene mala perf en la práctica a medida que
aumenta la carga. (en estudios se validó que a partir de 30% de carga aprox
ya se degrada mucho)</li>
<li>En el gráfico se hace mención de non-persistent CSMA. La diferencia entre
este y 1p-CSMA/CD es que 1p-CSMA/CD transmite ni bien encuentra el canal
libre. En cambio el non persistent sensa el canal y si está en uso espera una
cantidad fija de tiempo (no transmite ni bien se libera). Si bien reduce las
changes de colisión también cae el throughput. Dicho eso reacciona mejor a la
relación entre carga y goodput.</li>
<li>Se hace obvia la relación entre el delay hasta poder transmitir (si espero
más entre cada transmisión) y el goodput, y cómo esto afecta al throughput
final.</li>
</ul>
<hr />
<p>TODO: Resumir diapos 20-24 inclusive (no encuentro referencia en la docu)</p>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="unidad_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="unidad_4.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="unidad_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="unidad_4.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
