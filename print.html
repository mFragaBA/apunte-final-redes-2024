<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apunte Final Teoria de las Comunicaciones 2024</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_0.html"><strong aria-hidden="true">1.</strong> Unidad 0 - Introducción, conceptos básicos</a></li><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">2.</strong> Unidad 1 - Nivel físico</a></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">3.</strong> Unidad 2 - Nivel de Enlace</a></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">4.</strong> Unidad 3 - Medios Compartidos</a></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">5.</strong> Unidad 4 - Nivel de Red</a></li><li class="chapter-item expanded "><a href="unidad_5.html"><strong aria-hidden="true">6.</strong> Unidad 5 - Ruteo</a></li><li class="chapter-item expanded "><a href="unidad_6.html"><strong aria-hidden="true">7.</strong> Unidad 6 - Nivel de Transporte</a></li><li class="chapter-item expanded "><a href="unidad_7.html"><strong aria-hidden="true">8.</strong> Unidad 7 - El problema de Congestión</a></li><li class="chapter-item expanded "><a href="unidad_8.html"><strong aria-hidden="true">9.</strong> Unidad 8 - Nivel de Aplicación</a></li><li class="chapter-item expanded "><a href="unidad_9.html"><strong aria-hidden="true">10.</strong> Unidad 9 - Seguridad</a></li><li class="chapter-item expanded "><a href="bibliografia.html"><strong aria-hidden="true">11.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Teoria de las Comunicaciones 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unidad-0---introducción-conceptos-básicos"><a class="header" href="#unidad-0---introducción-conceptos-básicos">Unidad 0 - Introducción, conceptos básicos</a></h1>
<p>El primer invento similar a lo que conocemos hoy en día como redes de
comunicación fue la del telégrafo. Luego, le siguió la del teléfono, y ambos
tenían una cualidad que persistió hasta aproximadamente la década del 70: la
<strong>conmutación de circuitos</strong>.</p>
<p>La conmutación de circuitos como indica el nombre implicaba que haya operarios
encargados de conectar a las dos personas / aparatos que querían iniciar una
comunicación (cof cof, <em>operadora, comuníqueme con pirulito</em>)</p>
<p>Este approach tiene varias desventajas, por lo que mayoritariamente entre los
años 1959-1969 se desarrollaron las ideas que nos llevaron a la <strong>conmutación
de paquetes</strong>, cuyo objetivo principal era resultar en una red más tolerante a
fallas. Cómo se logró esto?</p>
<ul>
<li>Redundancia: que haya múltiples caminos entre dos puntos de la red</li>
<li>Descentralizada: toleracia a censura</li>
<li>División en fragmentos de los mensajes cosa de que puedan tomar caminos
diferentes.</li>
</ul>
<p><em>ARPANET</em> (Advanced Research Projects Agency Network) fue uno de los más importantes.</p>
<h2 id="estandarización"><a class="header" href="#estandarización">Estandarización</a></h2>
<p>Las tecnologías de redes con conmutación de paquetes se suiguieron
desarrollando, terminando a mediados de los 80 con una situación en la que
tenías muchas redes distintas cada una con su implementación particular y sus
propios detalles. Se empieza a hablar de la idea de tener una red única (en
mayo de 1983 ISO publica “ISO 7498:The Basic Reference Model for Open Systems
Interconnection” como un estándar internacional)</p>
<p><img src="./img/osi_model.png" alt="Diagrama Modelo OSI" /></p>
<p>El modelo OSI describe tódo lo que sucede con la información en una
comunicación entre dos puntos. Parte el proceso en 7 capas, en la que cada una
tiene un fin particular y cuyas entidades relevantes son definidas por eso. Por
ejemplo, en la capa de aplicación tu entidad puede ser un archivo mientras que
en la capa de de red tu entidad puede ser el paquete.</p>
<p>Si bien se usa el modelo OSI para estudiar teoría de comunicaciones, hoy en día
el verdadero ganador fue el modelo de TCP/IP, en donde hay 4 capas en lugar de
las 7 que propone OSI</p>
<p><img src="./osi_tcp_differences.png" alt="Diferencias OSI vs TCP/IP" /></p>
<div id="admonition-osi-the-internet-that-wasnthttpsspectrumieeeorgosi-the-internet-that-wasnt" class="admonition admonish-info">
<div class="admonition-title">
<p><a href="https://spectrum.ieee.org/osi-the-internet-that-wasnt">osi the internet that wasnt</a></p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-osi-the-internet-that-wasnthttpsspectrumieeeorgosi-the-internet-that-wasnt"></a></p>
</div>
<div>
<p>TLDR: OSI y TCP/IP compitieron durante un tiempo, pero una de las mayores
diferencias radicaba en que OSI era un protocolo que se estaba gestando por un
comité conformado por gente de la industria y cada uno quería tener su
influencia sobre el protocolo. Esto resultó en problemas para ponerse de
acuerdo y en un modelo que si bien era completo era mucho más difícil de
implementar, más caro y complejo.</p>
<p>Mientras seguían discutiendo sobre el estándar de OSI, TCP/IP ya se estaba usando...</p>
</div>
</div>
<h2 id="nivel-físico"><a class="header" href="#nivel-físico">Nivel Físico</a></h2>
<h3 id="sistema-de-comunicaciones"><a class="header" href="#sistema-de-comunicaciones">Sistema de Comunicaciones</a></h3>
<p>Modelo: tengo fuente de info -&gt; Emisor -&gt; ----- canal de comunicación ----- -&gt; Receptor -&gt; Destino</p>
<ul>
<li>Qué es información?</li>
<li>Qué es un canal?
<ul>
<li>guiado (cable)</li>
<li>no guiado (inalámbrico)</li>
</ul>
</li>
<li><strong>Siempre</strong> me ingresa ruido (alto o bajo)</li>
</ul>
<div id="admonition-ejemplo" class="admonition admonish-info">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-ejemplo"></a></p>
</div>
<div>
<p>Hablo en meet y tengo a mi gato maullando. Tengo que hablar más fuerte. Más
fuerte = mejor? Bueno no, lo que importa es la relación entre cuánto grito y el
ruido ambiente.</p>
</div>
</div>
<ul>
<li>Relación Señal / Ruido</li>
<li>La señal tiende a atenuarse a mayor distancia. Si se achica la señal y el
ruido es constante, entonces se achica la capacidad de transmisión también.</li>
<li>Lo importante de señal:
<ul>
<li>Es una onda electromagnética</li>
<li>Se propaga a la velocidad de la luz (a un ~70% de la velocidad de la luz en el vacío)</li>
<li><em>Demora</em>, no es instantáneo (es un límite físico, no lo puedo evitar)
<ul>
<li><strong>Tiempo de propagación</strong></li>
<li>RTT (Round Trip Time) entre USA y ARG = 100ms</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Frecuencia \(f\) = Cantidad de ciclos que entran en un segundo</p>
<p>Longitud de onda \(\lambda\) = \(c\) (velocidad de la luz) \(/ f\)</p>
<ul>
<li>a mayor frecuencia menor longitud de onda (\(c\) es constante)</li>
</ul>
<p>Glosario:</p>
<ul>
<li>Amplitud</li>
<li>Frecuencia Angular (= \(2 \pi f\))</li>
<li>Frecuencia Temporal (\(f\))</li>
<li>Período = \(\frac{1}{f}\)</li>
<li>Fase (desplazamiento)</li>
</ul>
<h3 id="dominio-transformado"><a class="header" href="#dominio-transformado">Dominio Transformado</a></h3>
<p>Lo anterior era orientado al dominio del tiempo. Idea: paso ese dominio a otro para procesarlo mejor:</p>
<ul>
<li>serie trigonométrica de fourier -&gt; puedo representar ordas cuadradas como una serie infinita de senos y cosenos
<ul>
<li>permite descomponer la señal en las distintas frecuencias</li>
</ul>
</li>
<li>transformada de fourier
<ul>
<li>lo anterior en la teoría. Esto en la práctica</li>
<li>esto es lo que en la práctica permite descomponer una señal en sus distintas armónicas / componentes de frecuencia</li>
</ul>
</li>
</ul>
<h3 id="ancho-de-banda"><a class="header" href="#ancho-de-banda">Ancho de banda</a></h3>
<p>Rango de frecuencias senoidales que pueden pasar por el medio sin ser atenuadas (&lt; 3db, esto es una generalización).</p>
<div id="admonition-pregunta-de-final" class="admonition admonish-warning">
<div class="admonition-title">
<p>Pregunta de Final</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-pregunta-de-final"></a></p>
</div>
<div>
<p>Tengo ancho de banda de 0 a 4 khz. Meto onda cuadrada periódica de 3khz en un canal con ancho de banda de 0 a 4khz. Qué obtengo a la salida?</p>
<p>Rta: Obtengo una onda senoidal de 3khz, porque la primera armónica tiene el
triple de frecuencia que la fundamental (en este caso es de 3 y la armónica ya
tiene 9), o sea que salvo la fundamental te filtra todo.</p>
</div>
</div>
<h3 id="teoría-de-la-información"><a class="header" href="#teoría-de-la-información">Teoría de la información</a></h3>
<p>(En el 48') Llega Shannon con su paper "A Mathematical Theory of
Communication". Ídolo, Genio, Maestro, Crack.</p>
<p>Idea fundamental:</p>
<ul>
<li>No interesa el significado del mensaje (No me importa si es teléfono, tele, internet, etc.)</li>
<li><strong>Teoría Clásica de la información</strong></li>
<li>Propone 2 teoremas fundamentales:
<ul>
<li>Codificación para una fuente sin ruido</li>
<li>Codificación para un canal con ruido</li>
</ul>
</li>
<li>Sorprendentemente nunca habla de cómo implementar nada</li>
</ul>
<p>Definición: qué es la información</p>
<p>$$
I(E) = log(\frac{1}{P(E)})
$$</p>
<p>La información que me da un evento es el logaritmo de la inversa de la
probabilidad de que ese evento suceda.</p>
<p><strong>Unidades</strong>:</p>
<ul>
<li>log en base 2? <em>1 bit</em> (por qué? Si tengo un dígito binario equiprobable \(I(\)sale 0/1\() = 1\)</li>
<li>(hay otros)</li>
</ul>
<h3 id="fuente-de-memoria-nula"><a class="header" href="#fuente-de-memoria-nula">Fuente de Memoria Nula</a></h3>
<p>Es el modelo que tomamos asumiendo que cada símbolo que emite es estadísticamente independiente del siguiente</p>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-info"></a></p>
</div>
<div>
<p>Con una fuente de memoria nula, \(E(s_i) = log(\frac{1}{P(s_i)})\) bits</p>
</div>
</div>
<h3 id="entropía"><a class="header" href="#entropía">Entropía</a></h3>
<p>Viene a representar algo así como la cantidad media de info por símbolo de la fuente (similar a Esperanza).</p>
<p>$$
\sum_S P(s_i)I(s_i) \text{  bits}
$$</p>
<p>Es algo como la cantidad de info que voy a obtener cuando observo un símbolo / evento.</p>
<p>Cuándo maximizo la info que me van a dar los eventos? Cuando los eventos son equiprobables.</p>
<div id="admonition-offtopic-recomendación" class="admonition admonish-info">
<div class="admonition-title">
<p>offtopic recomendación</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-offtopic-recomendación"></a></p>
</div>
<div>
<p>3b1b tiene un video en el que habla de entropía y lo aplica al wordle</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/v68zYyaEmEA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
</div>
<h3 id="extensión-de-la-fuente-de-memoria-nula"><a class="header" href="#extensión-de-la-fuente-de-memoria-nula">Extensión de la Fuente de Memoria Nula</a></h3>
<p>En vez de considerar de a un bit, agrupo varios bits juntos</p>
<h3 id="codificación"><a class="header" href="#codificación">Codificación</a></h3>
<p>Codificación sería el proceso por el cual mappeamos los símbolos de la fuente a
símbolos de un alfabeto asociado. Por qué hacemos esto? En primer lugar porque
a veces no tenemos una representación sencilla con la que trabajar. Y segundo
porque dependiendo el tipo de codificación que usemos vamos a obtener una mejor
o peor eficiencia.</p>
<ul>
<li>Le decimos <strong>código bloque</strong> a una codificación que asigna cada símbolo de la
fuente a una secuencia de símbolos del alfabeto destino.</li>
<li>Si la codificación es una función <strong>inyectiva</strong>, decimos que la codificación
es <strong>no singular</strong></li>
<li>Y decimos que una codificación es <strong>unívocamente decodificable</strong> si ninguna
tira de símbolos del código (o sea los códigos generados) admite más de una
única decodificación.</li>
<li>Por último, decímos que un código es <strong>instantáneo</strong> si es posible
decodificar sin ver los símbolos que suceden (no tiene que hacer look ahead)</li>
</ul>
<div id="admonition-condicion-de-los-prefijos" class="admonition admonish-info">
<div class="admonition-title">
<p>condicion de los prefijos</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-condicion-de-los-prefijos"></a></p>
</div>
<div>
<p>Una condición <strong>necesaria y suficiente</strong> para que un código sea
<strong>instantáneo</strong>, es que no haya palabra en el alfabeto que sea prefijo de la
misma. Ojo, dos palabras pueden tener un mismo prefijo común siempre que el
mismo no pertenezca al alfabeto.</p>
<p>Teorema: Instantáneo =&gt; unívocamente decodificable</p>
</div>
</div>
<ul>
<li>En ascii tenemos 8 digitos binarios por símbolo</li>
<li>Sin embargo, en morse tenemos una cantidad variable</li>
</ul>
<p>Pensemos ahora que lo que mandamos son mensajes, y para representar cada
mensaje (\(m_i\)) lo representamos con una palabra de longitud \(L_i\). Y
nuestro símbolo se codifica con cadenas de un alfabeto de \(r\) símbolos.</p>
<p>Para esto último se define la <strong>longitud media de un código</strong>. Es la
probabilidad de ocurrencia de cada símbolo por su longitud. Sería como la
esperanza de la longitud de recibir un símbolo, o algo así.</p>
<p>$$
L = \sum{p_i L_i}
$$</p>
<p>Cómo lo minimizo? Al que más probabilidad tenga, le doy el código más chico.</p>
<p>Otra cosa más, es que para asegurar que no haya pérdida de información requiero
que:</p>
<p>$$
L log(r) \geq H(S)
$$</p>
<p>Donde \(log(r)\) es la cantidad promedio máxima de info de un símbolo del código (por lo que vimos antes).</p>
<p>Definimos con esa desigualdad la <strong>eficiencia de un código</strong> \(h\) como:</p>
<p>$$
h = \frac{H(s)}{L log(r)}
$$</p>
<p>y \(h_{max} = 1\)</p>
<h3 id="codificación-de-huffmann"><a class="header" href="#codificación-de-huffmann">Codificación de Huffmann</a></h3>
<p>Es un método que permite construir codificadores óptimos en base a la
frecuencia en la que aparecen los símbolos (de la fuente).</p>
<h2 id="medios-de-transmisión-reales"><a class="header" href="#medios-de-transmisión-reales">Medios de Transmisión Reales</a></h2>
<p>Cualquier canal de comunicación:</p>
<ul>
<li>Está expuesto a ruido</li>
<li>Tiene problemas de potencia</li>
<li>Tienen problemas de ancho de banda</li>
</ul>
<h3 id="fórmula-de-capacidad-de-shannon-para-un-canal-sujeto-a-ruido"><a class="header" href="#fórmula-de-capacidad-de-shannon-para-un-canal-sujeto-a-ruido">Fórmula de capacidad de Shannon para un canal sujeto a ruido</a></h3>
<p>$$
C_max(bps) = B(\text{hz}) log_2(1 + \text{SNR})
$$</p>
<div id="admonition-snr-para-capacidad-de-shannon" class="admonition admonish-info">
<div class="admonition-title">
<p>SNR para capacidad de Shannon</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-snr-para-capacidad-de-shannon"></a></p>
</div>
<div>
<p>La relación señal-ruido de la capacidad de Shannon se expresa como logaritmos:</p>
<p>$$
SNR_{db} = 10 log_{10}(\text{SNR}) = 10 log_{10}(\frac{\text{PotenciaSeñal}}{\text{PotenciaRuido}})
$$</p>
<p>Por qué la escala logarítmica?</p>
<p>Es para ajustarse a las magnitudes. La atenuación es logarítmica, el oido tiene
respuesta logarítmica, etc. Y la escala logarítmica resulta más práctico (sobre
todo para visualizar)</p>
</div>
</div>
<h3 id="intro-a-nyquist"><a class="header" href="#intro-a-nyquist">Intro a Nyquist</a></h3>
<p>El ñato este tiró una fórmula para la capacidad máxima en canales <strong>sin ruido</strong>:</p>
<ul>
<li>
<p>2 niveles:
$$
C = 2B(\text{Hz})
$$</p>
</li>
<li>
<p>\(M\) niveles:
$$
C = 2B(\text{Hz})log_2(M)
$$</p>
</li>
</ul>
<p>Sin embargo hay una restricción, \(M\) tiene que ser más chico que \(\sqrt(1 + \text{SNR})\)</p>
<div id="admonition-pregunta-de-final-alert" class="admonition admonish-warning">
<div class="admonition-title">
<p>Pregunta de final alert</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-pregunta-de-final-alert"></a></p>
</div>
<div>
<p><strong>Qué es el delay?</strong></p>
<p>Está formado por:</p>
<ul>
<li>el tiempo de propagación</li>
<li>el tiempo de transmisión</li>
<li>el tiempo de encolamiento</li>
<li>el tiempo de procesamiento</li>
</ul>
<p>Notar que sólo el tiempo de propagación ya te puede estar limitando porque
transmitimos casi a la velocidad de la luz y sin embargo para mandar 1 bit por
10000km por fibra tengo un tiempo de propagación aproximado de 50ms (y por lo
tanto 100ms de RTT).</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-1---nivel-físico"><a class="header" href="#unidad-1---nivel-físico">Unidad 1 - Nivel Físico</a></h1>
<p>La fórmula de Shannon pone un límite en la tasa de transmisión, pero no en la
probabilidad de error. En teoría se podría minimizar arbitrariamente la
probabilidad de error usando una codificación lo suficientemente combleja y
obviamente con \(R_b \leq C\). Al no cumplir esto último esa idea de
minimizar la probabilidad de error arbitrariamente ya no es posible.</p>
<p><img src="./img/shannon_limit_graph.png#center" alt="Gráfico de SNR en base a la relación de la capacidad y el ancho de banda" /></p>
<p>Si graficamos la relación entre la SNR y la relación capacidad sobre ancho de
banda obtenemos el gráfico de arriba, que de alguna forma nos da valores para
lo que es posible y lo que no. En la práctica se busca asemejarse lo más
posible a la función graficada, buscando aumentar la cantidad de bits/s.</p>
<div id="admonition-pregunta-de-final" class="admonition admonish-warning">
<div class="admonition-title">
<p>pregunta de final</p>
<p><a class="admonition-anchor-link" href="unidad_1.html#admonition-pregunta-de-final"></a></p>
</div>
<div>
<p>Tengo un canal de ancho de banda de 0 a 2 Mhz, cuál es la forma de la onda de
salida si inyecto una señal de 1 Mhz. Sólamente obtengo la fundamental ya que a
partir de la tercer armónica que no entra en el ancho de banda.</p>
</div>
</div>
<h2 id="medios-de-transmisión"><a class="header" href="#medios-de-transmisión">Medios de transmisión</a></h2>
<p>Hoy en día tenemos internet compuesta por provedores que tiene tecnologías de acceso:</p>
<ul>
<li>Fibra</li>
<li>Cable</li>
<li>Satélite</li>
<li>Wifi</li>
<li>Celular</li>
</ul>
<p><img src="./img/internet_diagram.png#center" alt="Gráfico de organización de Internet" /></p>
<p>Las ondas electromagnéticas "necesitan" (en realidad no necesitan nada, se
pueden propagar por el vacío) un <strong>medio de transmisión</strong> por el cuál
transmitirse. Pueden ser:</p>
<ul>
<li>Guiados: Cable
<ul>
<li>de cobre</li>
<li>coaxil</li>
<li>fibra óptica</li>
</ul>
</li>
<li>No guiados: El espacio, libre
<ul>
<li>por radio</li>
<li>microondas</li>
<li>ondas infrarojas</li>
<li>laser</li>
<li>satélite</li>
<li>luz</li>
</ul>
</li>
</ul>
<h2 id="red-telefónica"><a class="header" href="#red-telefónica">Red telefónica</a></h2>
<p>Vamos a tomar de ejemplo a la red telefónica ya que muchos de los conceptos se
replican en otros medios de tecnologías.</p>
<ul>
<li>mediante conmutación de circuitos</li>
</ul>
<h3 id="multiplexación"><a class="header" href="#multiplexación">Multiplexación</a></h3>
<p>Multiplexar consiste en poder tener varias comunicaciones simultáneas en un
mismo troncal físico.</p>
<p>Podemos multiplexar:</p>
<ul>
<li>por tiempo: una suerte de round robin</li>
<li>por división frecuencia: transmito a través de las distintas bandas
<ul>
<li>el circuito para esto suele ser más complejo</li>
<li>al tener menos ancho de banda es "más lento", pero tengo más uptime</li>
</ul>
</li>
<li>por división de onda: lo mismo que antes pero aplicado a sistemas ópticos</li>
</ul>
<p><img src="./img/multiplexation_time_vs_freq.png#center" alt="Multiplexación por Frecuencia vs Tiempo" /></p>
<h2 id="taxonomía-de-redes"><a class="header" href="#taxonomía-de-redes">Taxonomía de Redes</a></h2>
<p>Las Redes de comunicaciones se pueden dividir en:</p>
<ul>
<li>Redes de conmutación de Circuitos</li>
<li>Redes de conmutación de Paquetes
<ul>
<li>Redes con Circuitos Virtuales</li>
<li>Redes de Datagramas (en el 99.999% de la materia vemos esto)
<ul>
<li>servicio sin conexión</li>
<li>el nivel de transporte brinda soporte para dar servicio orientado a conexión también (ej: TCP)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Las redes de conmutación de paquetes se basan en el concepto de
<strong>multiplexación estadística</strong>. Mi conmutador tiene un buffer y despacha de a
poco en base a algún criterio en base a la dirección origen y destino de dichos
paquetes.</p>
<p>Esta idea también implica que cada paquete compite con otros por ser enviado y
puede llevarnos a situaciones de congestión.</p>
<h2 id="conversión-analógico-digital"><a class="header" href="#conversión-analógico-digital">Conversión Analógico Digital</a></h2>
<p>Tengo 2 Etapas:</p>
<ol>
<li>Primero una etapa de muestreo
<ul>
<li>Gracias a Nyquist sabemos que debemos muestrear al doble del ancho de banda (por lo menos)</li>
<li>Además, tengo que definir con cuántos dígitos binarios uso para representar cada muestra</li>
</ul>
</li>
<li>Segundo cuantifico dichas muestras (o sea mando el valor a su representación binaria correspondiente)
<ul>
<li>Hoy en día a esa técnica la llamamos <em>PCM</em> (<strong>P</strong>ulse <strong>C</strong>ode <strong>M</strong>odulation)</li>
</ul>
</li>
</ol>
<h3 id="teorema-del-muestreo-nyquist"><a class="header" href="#teorema-del-muestreo-nyquist">Teorema del muestreo (Nyquist)</a></h3>
<p>Si queremos Reconstruir una señal cuya frecuencia máxima es \(f_m\) debemos
muestrar dicha señal a una razón de \(f_s &gt; 2 * f_m\) llamada <strong>frecuencia de
muestreo</strong></p>
<div id="admonition-ejemplo-con-red-de-computadoras" class="admonition admonish-info">
<div class="admonition-title">
<p>Ejemplo con red de computadoras</p>
<p><a class="admonition-anchor-link" href="unidad_1.html#admonition-ejemplo-con-red-de-computadoras"></a></p>
</div>
<div>
<p><img src="./img/modem_and_codec.png#center" alt="" /></p>
<p>Este es un diagrama (un poco antiguo). Las oficinas interurbanas operaban en
digital, por lo que era necesario que la señal originalmente analógica sea
convertida a una señal digital.</p>
<p>Uno en casa entonces tenía un modem, que emitía una señal analógica y luego le
seguía un codec que se encargaba de hacer la conversión analógico digital. Del
otro lado de la red, estaba un codec que cumplía la función inversa y un modem
por cliente.</p>
<p>Si lo pensamos con el caso del teléfono, la mayoría de las comunicaciones por
voz se pueden agrupar en el rando de 0-4Khz, por lo tanto se necesita una tasa
de muestreo de 8Khz o 8000 muestras por segundo. Como en ese caso cada muestra
se codificaba en 8 bits (En realidad son 7 bits para la data y 1 para
sincronización), era necesario un ancho de banda (I know, está mal usar este
término) de 64kbps.</p>
</div>
</div>
<h2 id="modulación"><a class="header" href="#modulación">Modulación</a></h2>
<h3 id="frecuencia-modulada-vs-amplitud-modulada"><a class="header" href="#frecuencia-modulada-vs-amplitud-modulada">Frecuencia Modulada vs Amplitud Modulada</a></h3>
<p><img src="./img/am_vs_fm.png" alt="" /></p>
<p>Tengo la Señal Portadora y la Señal Modulante.</p>
<ul>
<li>Frecuencia Modulada es cuando la frecuencia de la portadora varía en base a la amplitud de la modulante.</li>
<li>Amplitud Modulada es cuando la amplitud de la portadora varía en base a la amplitud de la modulante.</li>
</ul>
<h3 id="modem"><a class="header" href="#modem">Modem</a></h3>
<p>Si volvemos al diagrama, la idea del modem era transformar la señal digital de
la computadora en una señal analógica para poder mandarla por los cables de
cobre (y posteriormente volver a ser convertida a digital por el codec 🤷).</p>
<p>El truco de los modems entonces es meter la información sobre una señal portadora que pueda pasar por el ancho de banda disponible. Para esto hay 3 técnicas de modulación de una señal digital sobre una analógica:</p>
<ul>
<li>Desplazamiento de amplitud (ASK)</li>
</ul>
<p><img src="./img/ask.png#center" alt="" /></p>
<ul>
<li>Desplazamiento de frecuencia (FSK)</li>
</ul>
<p><img src="./img/fsk.png#center" alt="" /></p>
<ul>
<li>Desplazamiento de fase (PSK)</li>
</ul>
<p><img src="./img/psk.png#center" alt="" /></p>
<ul>
<li>
<p><strong>Velocidad de Modulación</strong> \(V_m\): es el número de cambios de señal por unidad de
tiempo. Se mide en Baudios (símbolos / segundo).</p>
</li>
<li>
<p><strong>Velocidad de Transmisión</strong>: \(V_m * N\), donde \(N\) es el número de
bits por símbolo. Se mide en bits por segundo.</p>
</li>
</ul>
<h3 id="lets-go-even-further"><a class="header" href="#lets-go-even-further">Let's go even further</a></h3>
<blockquote>
<p>Recomendación: si tienen dudas lean esta parte del Tanenbaum, en el Peterson no está.</p>
</blockquote>
<p>Vieron que dijimos que la velocidad de Modulación la medimos en símbolos por
segundo, y no en base a la cantidad de bits. Bueno, tranquilamente podemos
asumir que no tengo un único canal binario si no muchos (varios bits), y la
combinación son los distintos símbolos a transferir.</p>
<p>Luego, lo que puedo hacer es modular para 2 bits en base a 4 frecuencias o 4 fases (QPSK) por
ejemplo. Esto es lo que se conoce como modulación multinivel.</p>
<p>También puedo combinar amplitud y fase (QAM) o amplitud y frecuencia (no puedo ambos
porque fase y frecuencia están relacionados). (hoy en día ya estamos llegando a 1024-QAM y 4096-QAM)</p>
<p><img src="./img/qpsk_and_gam.png#center" alt="" /></p>
<p>Y puedo agregar tantos niveles como quiera, pero fijate que a medida que agrego
más puntos, hago más finita la cuadratura. Con lo cual es más vulnerable al
ruido.</p>
<p>El error generado se llama <em>MER</em>, y se expresa en db como:</p>
<p>$$
\text{MER} = 10 log \frac{\text{RMS error magnitude}}{\text{average symbol magnitude}}
$$</p>
<div id="admonition-dato-de-color-sobre-wi-fi" class="admonition admonish-info">
<div class="admonition-title">
<p>Dato de color sobre Wi-Fi</p>
<p><a class="admonition-anchor-link" href="unidad_1.html#admonition-dato-de-color-sobre-wi-fi"></a></p>
</div>
<div>
<p>A medida que me alejo del router y pierdo señal, aumenta la <em>SNR</em> y por ende me
cuesta más distinguir cada símbolo de QAM. Entonces lo que hace Wi-Fi es
achicar la cantidad de símbolos y por ende baja de QAM-1024 (ponele) a QAM-256,
y por ende baja su velocidad para evitar errores en la transmisión.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-2---nivel-de-enlace"><a class="header" href="#unidad-2---nivel-de-enlace">Unidad 2 - Nivel de Enlace</a></h1>
<p>Tanto OSI como TCP usan un modelo basado en <em>capas</em>. Cada Entidad separa su
funcionalidad en varias capas. Cada capa agrega info de control, mediante el
agregado de headers. De esta forma la capa agrega / interpreta los headers o
frames enviados / recibidos y permite que haya una comunicación entre las capas
adyacentes pero a su vez capa a capa entre los distintos hosts.</p>
<p><img src="./img/control_info.png" alt="" /></p>
<p>Además, el servicio que una capa le brinda a otra se puede clasificar en:</p>
<ul>
<li><strong>sin conexión y sin reconocimiento</strong> (ej: UDP)</li>
<li><strong>sin conexión y con reconocimiento</strong> (ej: uso de ACK en capa 2 de OSI)</li>
<li><strong>orientado a conexión</strong> (ej: websockets, TCP)</li>
</ul>
<p>El objetivo de los protocolos de comunicación (nivel de enlace en OSI), buscan en proveer:</p>
<ul>
<li>confiabilidad</li>
<li>control de errores</li>
<li>control de flujo</li>
</ul>
<p>Un ejemplo para garantizar control de errores sería agregar un CRC / checksum
que el receptor valida. Si el receptor detecta que el mensaje es inválido,
basta con que no mande un ACK (aknowledge) de que recibió el mensaje.</p>
<h2 id="control-de-errores"><a class="header" href="#control-de-errores">Control de errores</a></h2>
<p>Si consideramos que lo que mandamos son <em>codewords</em> de \(n\) bits, compuestos
por \(m\) bits de datos y \(r\) bits de redundancia y siendo \(d\) la
distancia mínima de Hamming entre 2 codewords posibles y \(e\) la cantidad de
bits erroneos para un cierto mensjae, necesitamos que se cumpla que:</p>
<ul>
<li>\(e + 1 \leq d\) para poder detectar que hubo errores</li>
<li>\(2*e + 1 \leq d\) para poder corregir errores</li>
</ul>
<blockquote>
<p>Si quieren ver un algoritmo para detección y corrección de errores pueden
chequear
<a href="https://www.cs.cmu.edu/~guyb/realworld/reedsolomon/reed_solomon_codes.html">Reed-Solomon</a></p>
</blockquote>
<h2 id="confiabilidad"><a class="header" href="#confiabilidad">Confiabilidad</a></h2>
<p>Para garantizar confiabilidad, va a ser necesario poder efectuar
<em>retransmisiones</em>. Esto se puede dar de forma <strong>implícita</strong> cuando se produce
un <strong>timeout</strong> (tiempo sin recibir un ACK de que se recibió el mensaje), o de
forma <strong>explícita</strong> si nuestro protocolo admite mensajes de control.</p>
<p>Cómo puedo hacer el ACK de cierto símbolo? Mediante números de secuencia. El
ACK entonces representa que el frame con cierto número de secuencia fue
recibido.</p>
<h3 id="primer-approach-stop-and-wait"><a class="header" href="#primer-approach-stop-and-wait">Primer approach: Stop and Wait</a></h3>
<ul>
<li>Espero a recibir el ACK para mandar el nuevo frame.</li>
<li>Dado que es "bloqueante", basta con tener un único bit para el número de secuencia.</li>
</ul>
<p>Qué pasa si ocurre lo siguiente:</p>
<ol>
<li>El emisor manda el primer frame</li>
<li>Transcurre el tiempo suficiente para que ocurra un timeout (en el medio el
Receptor recibe el frame pero no responde a tiempo)</li>
<li>El emisor vuelve a mandar el primer frame</li>
<li>El emisor recibe el ACK del primer frame</li>
<li>El receptor recibe el primer frame y manda el ACK</li>
<li>El emisor recibe por segunda vez el ACK del primer frame</li>
</ol>
<p>Ese fenómeno es lo que se conoce como el <strong>problema del solapamiento</strong> o el
<strong>problema de las reencarnaciones</strong>, y los distintos approaches van a buscar
problemas de lidiar con esto.</p>
<h3 id="eficiencia-de-un-protocolo"><a class="header" href="#eficiencia-de-un-protocolo">Eficiencia de un protocolo</a></h3>
<p>Queremos evaluar cuánto tiempo se está transmitiendo vs cuánto tiempo se está
esperando por confirmaciones. Lo definimos como:</p>
<p>$$
\eta_{proto} = \frac{T_{tx}}{\text{RTT}(F)}
$$</p>
<blockquote>
<p>Pregunta: Tiene sentido que \(\eta_{proto} &gt; 1\)?</p>
</blockquote>
<h3 id="segundo-approach-ventana-deslizante"><a class="header" href="#segundo-approach-ventana-deslizante">Segundo approach: Ventana deslizante</a></h3>
<p>Para el caso de Stop and Wait, notar que transmito la mitad de lo que dura el
RTT y después espero, entonces tengo una eficiencia del 0,5. Queremos hacerlo
mejor.</p>
<p>Idea: mando varios frames seguidos, sin esperar al ACK. Esto es el concepto de
<strong>ventana de frames</strong>, y en ese caso el cálculo de la eficiencia cambia
ligeramente:</p>
<p>$$
\eta_{proto} = \frac{T_{tx}(V)}{\text{RTT}(F)}
$$</p>
<p>Ahora el \(T_{tx}(V)\) es el tiempo que me tarda mandar todos los frames de
la ventana, mientras que el \(\text{RTT}(F)\) es lo que tarda en volverme el
ACK del primer frame que mandé.</p>
<ul>
<li>Requiero de más bits para el número de secuencia (tiene que permitirme
identificar todos los frames de la trama por lo menos)</li>
<li>A medida que recibo los ACk voy desplazando la ventana (ojo porque ahora hay
que determinar cuándo desplazo la ventana. Siempre que recibo? O sólo si
recibí el siguiente al último que tenía reconocido?)</li>
</ul>
<p>Para buscar la mejor eficiencia posible se define como tamaño de ventana (en
frames) a:</p>
<p>$$
\text{SWS} = \frac{V_{tx} * RTT}{|Frame|}
$$</p>
<p>Y envío un frame nuevo siempre que \(\text{UltimoFrameEnviado} \leq \text{UltimoFrameReconocido} + \text{SWS}\)</p>
<h3 id="acks-acumulativos-vs-selectivos"><a class="header" href="#acks-acumulativos-vs-selectivos">ACKs acumulativos vs selectivos</a></h3>
<p>En la sección anterior faltó mencionar cuál es el comportamiento esperado del
receptor ante algún error. El primer approach es el de ACKs acumulativos, en
donde a partir de que se produce un error en la transmisión el receptor ignora
todos los mensajes posteriores hasta que el frame con error se reenvía y recibe
correctamente. (Esta idea de retransmitir todo se lo conoce también como
<strong>GoBackN</strong>)</p>
<p><img src="./img/sliding_window_gobackn.png#center" alt="" /></p>
<p>Ahora, también podría pedir que el receptor tenga un buffer que permita guardar
los frames que va recibiendo, y en ese caso basta con que el receptor mande una
señal pidiendo el frame específico.</p>
<p><img src="./img/sliding_window_sack.png#center" alt="" /></p>
<p>Para ambos casos definimos la ventana de recepción \(\text{RWS}\) como:</p>
<p>$$
\text{RWS} =
\begin{cases}
\text{SWS},  &amp; \text{si hay SACK} \\
1, &amp; \text{en caso contrario}
\end{cases}
$$</p>
<p>Además, como se puede dar acá también el problema de las reencarnaciones, es
necesario poder distinguir por lo menos \(SWS + RWS\) frames distintos.</p>
<h3 id="sobre-la-eficiencia-de-la-ventana"><a class="header" href="#sobre-la-eficiencia-de-la-ventana">Sobre la eficiencia de la ventana</a></h3>
<p>Primero necesito que definamos algunos conceptos:</p>
<ul>
<li>El <strong>tiempo de transmisión</strong> \(T_{tx} = \frac{|datos|}{V_{tx}}\) es el
tiempo para enviar todos los bits de un frame a través del medio de
transmisión.
<ul>
<li>Ocupa una porción significativa de tiempo en conexiones lentas o donde el
frame es muy grande.</li>
</ul>
</li>
<li>El <strong>tiempo de propagación</strong> \(T_{prop} = \frac{distancia}{V_{prop}}\) es
el tiempo desde que el bit es transmitido hasta que llega al receptor.
<ul>
<li>La velocidad de propagación \(V_{prop}\) es algo propio del medio de
transmisión, por lo general cercano a la velocidad de la luz (suele ser
una constante multiplicada por la velocidad de la luz).</li>
<li>Ocupa una porción significativa de tiempo en conexiones entre dos puntos
muy lejanos.</li>
</ul>
</li>
<li>El <strong>tiempo de encolamiento</strong> \(T_{queue}\) es el tiempo que espera un
frame en un buffer hasta ser transmitido. Dependiendo del estado de
congestión de la red puede ser significativo o no.</li>
<li>El <strong>tiempo de procesamiento</strong> \(T_{proc}\) es el tiempo que se tarda en
leer el header de un frame y decidir qué hacer con él. En la práctica se lo
asume nulo o poco significativo.</li>
</ul>
<p>Por último, la <strong>capacidad de volumen</strong> \(C_{vol}\) de un canal sería la cantidad de bits
que entran en el canal desde que se envía el primer bit hasta que llega al
receptor (una suerte de flujo máximo de bits para quienes hayan cursado algo
III).</p>
<p>$$
C_{vol} = \text{Delay} * V_{tx}
$$</p>
<p>Sin embargo, para los protocolos punto a punto se es un poco más
específico y se mide como la cantidad de bits que entran <strong>hasta recibir el
primer ACK</strong></p>
<p>$$
C_{vol} = \text{RTT} * V_{tx}
$$</p>
<p>(Recuerdo: antes mencionamos que el tamaño óptimo de ventana era \(SWS = \frac{\text{RTT} * V_{tx}}{|frame|} = \frac{C_{vol}}{|frame|}\))</p>
<p>Entonces... ¿Por qué es óptimo?</p>
<p>Recordamos que la eficiencia del protocolo de ventana deslizante se medía como:</p>
<p>$$
\eta_{proto} = \frac{T_{tx}(V)}{\text{RTT}(F)}
$$</p>
<p>\(T_{tx}(V)\) Era el tiempo que tardaba en mandar todos los frames de la ventana. Eso lo podemos pensar como:</p>
<p>$$
T_{tx}(V) = \frac{SWS * |frame|}{V_{tx}}
$$</p>
<p>Entonces:</p>
<p>$$
\eta_{proto} = \frac{SWS * |frame|}{V_{tx} * \text{RTT}(F)} \\
SWS = \eta_{proto} * \frac{V_{tx} * \text{RTT}(F)}{|frame|}
$$</p>
<p>Y asumiendo que \(\eta_{proto} = 1\) dado que es óptimo obtenemos que:</p>
<p>$$
SWS = \frac{V_{tx} * \text{RTT}(F)}{|frame|}
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-3---medios-compartidos"><a class="header" href="#unidad-3---medios-compartidos">Unidad 3 - Medios Compartidos</a></h1>
<p>Antes vimos que se podía compartir un canal de transmisión mediante técnicas
como la multiplexación por tiempo o por frecuencia. Esas técnicas lo que
permitían era lograr que varios nodos utilicen el medio "de forma
independiente", o sea que la transmisión de un dispositivo no interfiera con la
de otro.</p>
<p>Ahora vamos a ver otro approach, que es sugerido y generalmente utilizado para
ethernet y en el protocolo de wifi (802.11). La idea es permitir que todos los
dispositivos usen el mismo canal para transferir, y si más adelante hay un
problema (ej 2 quieren transmitir al mismo tiempo) ahí se ve cómo se resuelve.</p>
<p>Y por supuesto se va a buscar minimizar la cantidad de intentos que tiene que
hacer un dispositivo para poder hacer el envio de paquetes deseado y asegurar
fairness.</p>
<p>La tecnología que usa Ethernet y otras redes inalámbricas (802.11), lleva el
nombre de Carrier Sense, Multiple Access with Collision Detect (CSMA/CD). Es un
protocolo que permite que un conjunto de nodos manden mensajes a través de un
enlace compartido.</p>
<ul>
<li>El <strong>Carrier Sense</strong> viene por el hecho de que todos los nodos pueden
distinguir en todo momento si un canal está libre o en uso.</li>
<li>Por otro lado, el <strong>Collision Detect</strong> viene por el hecho de que el emisor a
medida que transmite sensa el canal y puede darse cuenta de si hubo una
colisión en la transmisión con otro nodo.</li>
</ul>
<p>La realidad es que hoy en día la mayoría de las conexiones cableadas son punto
a punto (o sea el enlace es propio de cada par de nodos). Y la parte de
multiplexación la resuelven los switches. Es por eso que hoy en día no está tan
presente el protocolo... redes cableadas.</p>
<p>Por otro lado las redes inalámbricas hoy en día son la norma en muchos entornos
con lo cual el uso de CSMA/CD retoma relevancia.</p>
<p><img src="./img/csma_cd_meme.png" alt="" /></p>
<div id="admonition-dominio-de-colisión" class="admonition admonish-info">
<div class="admonition-title">
<p>Dominio de Colisión</p>
<p><a class="admonition-anchor-link" href="unidad_3.html#admonition-dominio-de-colisión"></a></p>
</div>
<div>
<p>Llamamos <strong>Dominio de Colisión</strong> al conjunto de los nodos que pueden generar
una colisión en el medio al intentar transmitir (no están incluidas los nodos
separados por medio de un switch).</p>
</div>
</div>
<h2 id="csmacd"><a class="header" href="#csmacd">CSMA/CD</a></h2>
<p>Vamos a ver el caso de acceso múltiple en cable ethernet ya que si bien es algo
anecdótico hoy en día, los mismos principios se pueden aplicar a nuevas
tecnologías.</p>
<p>Para empezar hablemos un toque de Ethernet:</p>
<ul>
<li>Admite tramos de hasta 500m (no más para evitar atenuación de la señal).</li>
<li>Admite máximo hasta 4 repetidores</li>
<li>Requiere como mínimo 2,5 metros entre host y host.</li>
<li>Las transmisiones son broadcasteadas a lo largo del cable (y a través de
repetidores)</li>
</ul>
<p>Además, un frame de Ethernet contiene los siguientes campos (segun el estándar 802.3):</p>
<p><img src="./img/eth_frame.png" alt="" /></p>
<ul>
<li>Primero tiene un preámbulo de 64 bits, es una secuencia de 0's y 1's
alternada que le permite al receptor sincronizarse con la señal.</li>
<li>Después le siguen las direcciones de destino y fuente respectivamente que son
direcciones de 48 bits.
<ul>
<li>las direcciones son "únicas" y vienen grabadas en la rom de los
adaptadores de red</li>
<li>El adaptador de red sensa el canal y si ve un frame cuyo campo de
destinatario es su dirección entonces le deriva el frame al host. Hace lo
mismo si el frame tiene la dirección de broadcast.</li>
</ul>
</li>
<li>Después sigue el campo del tipo, que indica a cuál protocolo de más alto
nivel se le enviaría el frame.</li>
<li>Luego el body del frame tiene la data en si a enviar. Un detalle no menor es
que un frame puede contener hasta 1500 bytes de datos, y tiene que tener por
lo menos 46 bytes de datos (esto último es necesario para tener tiempo
suficiente de detectar una colisión) por lo que en caso de no tener
suficientes datos se le agrega algo de padding.</li>
<li>Por último un campo CRC para chequeo de errores</li>
</ul>
<p>Un pequeño detalle es que para el host el frame de ethernet en realidad no
tiene ni el preámbulo ni el CRC, el adaptador de red es el que se encarga de
agregar esos campos extra.</p>
<p>El algoritmo que sigue un transmisor que implementa CSMA/CD se puede resumir con el siguiente diagrama de estados:</p>
<p><img src="./img/csma_cd_state_diagram.png" alt="" /></p>
<ul>
<li>El transmisor siempre que le llega un frame nuevo va a intentar transmitir
<ul>
<li>Si el canal está libre transmite de una</li>
<li>Si el canal está ocupado, espera a que se libere
<ul>
<li>Ni bien se libera, el transmisor va a intentar enviar</li>
</ul>
</li>
</ul>
</li>
<li>Si está transmitiendo, pueden pasar 1 de 2 cosas:
<ul>
<li>Es el único dispositivo usando el canal y el frame se envía correctamente
y sin problemas</li>
<li>Mientras está enviando, otro dispositivo también decide enviar un frame,
generando lo que se conoce como una <strong>colisión</strong>. Para eso el transmisor
sensa el medio y si detecta un voltage anormal entonces eso es a causa de
la colisión
<ul>
<li>Cuando detecta una colisión frena la transmisión actual y envía una
<strong>secuencia de jamming</strong> de 32 bits (por lo general es una tira de
1's y listo). El objetivo de dicha secuencia es hacer que el receptor
deje de escuchar la señal.
<ul>
<li>Eventualmente el otro emisor también va a detectar la colisión y
va a enviar su propia secuencia de jamming.</li>
</ul>
</li>
<li>Una vez que se detecta la colisión y se envía la secuencia de
jamming, se aplica una política de <strong>exponential backoff</strong>. Eso es
esperar un cierto tiempo antes de enviar. Si se vuelve a dar una
colisión, esperar el doble y así hasta que se haga efectiva o se
supere un límite predefinido (en general es de 16 intentos), en cuyo
caso el adaptador avisa al host que la transmisión falló.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div id="admonition-exponential-backoff" class="admonition admonish-info">
<div class="admonition-title">
<p>Exponential Backoff</p>
<p><a class="admonition-anchor-link" href="unidad_3.html#admonition-exponential-backoff"></a></p>
</div>
<div>
<p>Para ser un poco más específico, la idea en el exponential backoff es dividir
el tiempo en slots entre 0 y \(2^k - 1\), siendo \(k\) la cantidad de
intentos. Se elige uno de los slots al azar y eso representa la cantidad de
slots que se espera. Un slot representa 51,2 \(\mu\)s que es el tiempo
necesario para transferir el frame más chico.</p>
</div>
</div>
<p>Ahora que conocemos el algoritmo, tiene más sentido el motivo por el cuál
necesitamos tener al menos 46 bytes de datos a enviar. Esto es porque incluso
en el caso en el que estén los dos hosts lo más alejados posible (2500 metros
usando 4 repetidores), el Round Trip Delay es de al rededor de 51,2 \(\mu\)s
que en una conexión de 10Mbps equivale a 512 bits. De esta forma, si nuestra
frame tiene al menos 512 bits si o si uno de los dos emisores va a detectar la
colisión antes de terminar de enviar su frame.</p>
<div id="admonition-transmisores-p-persistentes" class="admonition admonish-info">
<div class="admonition-title">
<p>Transmisores <em>p</em>-persistentes</p>
<p><a class="admonition-anchor-link" href="unidad_3.html#admonition-transmisores-p-persistentes"></a></p>
</div>
<div>
<p>Ethernet se dice que es un protocolo 1-persistente porque siempre que sensa el
medio y está libre va a intentar enviar. Este es un caso particular de lo que
se conoce como transmisores <em>p</em>-persistentes, en donde se transmite con
probabilidad <em>p</em> una vez que se libera el medio.</p>
</div>
</div>
<p>Una última observación es que en este algoritmo se contempla que sólo se puede
leer <em>o</em> escribir en el canal, pero no los 2 al mismo tiempo. Eso se conoce
como un algoritmo de <strong>half-duplex</strong>. No confundir esto con la clasificación de
canales. El canal puede ser full duplex (se puede escuchar y enviar al mismo
tiempo) mientras que el algoritmo es half duplex.</p>
<p>Recomiendo también pegarle una chusmeada a <a href="https://cs.newpaltz.edu/~easwarac/CCN/Week13/CSMA.pdf">esta explicación</a> de CSMA/CD.</p>
<h3 id="midiendo-performance-de-csma"><a class="header" href="#midiendo-performance-de-csma">Midiendo performance de CSMA</a></h3>
<p>Sean \(S\) la <strong>carga ofrecida</strong> (nro de intentos de transmisión por unidad
de tiempo, o sea cuánto tengo que usar del medio para transmitir) y \(G\) el
<strong>goodput</strong> (proporción de transmisiones exitosas por unidad de tiempo),
entonces:</p>
<p>$$
S = G * (1 - P_{colision})
$$</p>
<p>Podemos graficar la relación entre la carga, el goodput y la variante de CSMA:</p>
<p><img src="./img/link_performance.png#center" alt="" /></p>
<ul>
<li>Aloha es otro protocolo que consiste en lo que vimos antes. Enviar un mensaje
y si no me llega un ACK de dicho mensaje re-enviar. (esto no descarta
totalmente ese mecanismo para asegurar confiabilidad y control de errores
porque como verems más adelante si se usa en protocolos de más alto nivel)
<ul>
<li>Slotted aloha es lo mismo pero la emisión se da en "slots discretos"</li>
</ul>
</li>
<li>CSMA es fácil de implementar pero tiene mala perf en la práctica a medida que
aumenta la carga. (en estudios se validó que a partir de 30% de carga aprox
ya se degrada mucho)</li>
<li>En el gráfico se hace mención de non-persistent CSMA. La diferencia entre
este y 1p-CSMA/CD es que 1p-CSMA/CD transmite ni bien encuentra el canal
libre. En cambio el non persistent sensa el canal y si está en uso espera una
cantidad fija de tiempo (no transmite ni bien se libera). Si bien reduce las
changes de colisión también cae el throughput. Dicho eso reacciona mejor a la
relación entre carga y goodput.</li>
<li>Se hace obvia la relación entre el delay hasta poder transmitir (si espero
más entre cada transmisión) y el goodput, y cómo esto afecta al throughput
final.</li>
</ul>
<hr />
<p>TODO: Resumir diapos 20-24 inclusive (no encuentro referencia en la docu)</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-4---nivel-de-red"><a class="header" href="#unidad-4---nivel-de-red">Unidad 4 - Nivel de Red</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-5---ruteo"><a class="header" href="#unidad-5---ruteo">Unidad 5 - Ruteo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-6---nivel-de-transporte"><a class="header" href="#unidad-6---nivel-de-transporte">Unidad 6 - Nivel de Transporte</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-7---el-problema-de-congestión"><a class="header" href="#unidad-7---el-problema-de-congestión">Unidad 7 - El problema de Congestión</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-8---nivel-de-aplicación"><a class="header" href="#unidad-8---nivel-de-aplicación">Unidad 8 - Nivel de Aplicación</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-9---seguridad"><a class="header" href="#unidad-9---seguridad">Unidad 9 - Seguridad</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliografía"><a class="header" href="#bibliografía">Bibliografía</a></h1>
<p>Libro de Cabecera de la materia:</p>
<ul>
<li>Larry L. Peterson and Bruce S. Davie. 2011. Computer Networks, Fifth edition: A Systems Approach. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.</li>
</ul>
<p>Libro complementario que no vimos en la materia pero me pareció didáctico:</p>
<ul>
<li><a href="https://catnip.article19.org/">How The internet really works - An Illustrated Guide to protocols, privacy, censorship, and governance</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
