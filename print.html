<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apunte Final Teoria de las Comunicaciones 2024</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_0.html"><strong aria-hidden="true">1.</strong> Unidad 0 - Introducci√≥n, conceptos b√°sicos</a></li><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">2.</strong> Unidad 1 - Nivel f√≠sico</a></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">3.</strong> Unidad 2 - Nivel de Enlace</a></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">4.</strong> Unidad 3 - Medios Compartidos</a></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">5.</strong> Unidad 4 - Nivel de Red</a></li><li class="chapter-item expanded "><a href="unidad_5.html"><strong aria-hidden="true">6.</strong> Unidad 5 - Ruteo</a></li><li class="chapter-item expanded "><a href="unidad_6.html"><strong aria-hidden="true">7.</strong> Unidad 6 - Nivel de Transporte</a></li><li class="chapter-item expanded "><a href="unidad_7.html"><strong aria-hidden="true">8.</strong> Unidad 7 - El problema de Congesti√≥n</a></li><li class="chapter-item expanded "><a href="unidad_8.html"><strong aria-hidden="true">9.</strong> Unidad 8 - Nivel de Aplicaci√≥n</a></li><li class="chapter-item expanded "><a href="unidad_9.html"><strong aria-hidden="true">10.</strong> Unidad 9 - Seguridad</a></li><li class="chapter-item expanded "><a href="bibliografia.html"><strong aria-hidden="true">11.</strong> Bibliograf√≠a</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Teoria de las Comunicaciones 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unidad-0---introducci√≥n-conceptos-b√°sicos"><a class="header" href="#unidad-0---introducci√≥n-conceptos-b√°sicos">Unidad 0 - Introducci√≥n, conceptos b√°sicos</a></h1>
<p>El primer invento similar a lo que conocemos hoy en d√≠a como redes de
comunicaci√≥n fue la del tel√©grafo. Luego, le sigui√≥ la del tel√©fono, y ambos
ten√≠an una cualidad que persisti√≥ hasta aproximadamente la d√©cada del 70: la
<strong>conmutaci√≥n de circuitos</strong>.</p>
<p>La conmutaci√≥n de circuitos como indica el nombre implicaba que haya operarios
encargados de conectar a las dos personas / aparatos que quer√≠an iniciar una
comunicaci√≥n (cof cof, <em>operadora, comun√≠queme con pirulito</em>)</p>
<p>Este approach tiene varias desventajas, por lo que mayoritariamente entre los
a√±os 1959-1969 se desarrollaron las ideas que nos llevaron a la <strong>conmutaci√≥n
de paquetes</strong>, cuyo objetivo principal era resultar en una red m√°s tolerante a
fallas. C√≥mo se logr√≥ esto?</p>
<ul>
<li>Redundancia: que haya m√∫ltiples caminos entre dos puntos de la red</li>
<li>Descentralizada: toleracia a censura</li>
<li>Divisi√≥n en fragmentos de los mensajes cosa de que puedan tomar caminos
diferentes.</li>
</ul>
<p><em>ARPANET</em> (Advanced Research Projects Agency Network) fue uno de los m√°s importantes.</p>
<h2 id="estandarizaci√≥n"><a class="header" href="#estandarizaci√≥n">Estandarizaci√≥n</a></h2>
<p>Las tecnolog√≠as de redes con conmutaci√≥n de paquetes se suiguieron
desarrollando, terminando a mediados de los 80 con una situaci√≥n en la que
ten√≠as muchas redes distintas cada una con su implementaci√≥n particular y sus
propios detalles. Se empieza a hablar de la idea de tener una red √∫nica (en
mayo de 1983 ISO publica ‚ÄúISO 7498:The Basic Reference Model for Open Systems
Interconnection‚Äù como un est√°ndar internacional)</p>
<p><img src="./img/osi_model.png" alt="Diagrama Modelo OSI" /></p>
<p>El modelo OSI describe t√≥do lo que sucede con la informaci√≥n en una
comunicaci√≥n entre dos puntos. Parte el proceso en 7 capas, en la que cada una
tiene un fin particular y cuyas entidades relevantes son definidas por eso. Por
ejemplo, en la capa de aplicaci√≥n tu entidad puede ser un archivo mientras que
en la capa de de red tu entidad puede ser el paquete.</p>
<p>Si bien se usa el modelo OSI para estudiar teor√≠a de comunicaciones, hoy en d√≠a
el verdadero ganador fue el modelo de TCP/IP, en donde hay 4 capas en lugar de
las 7 que propone OSI</p>
<p><img src="./osi_tcp_differences.png" alt="Diferencias OSI vs TCP/IP" /></p>
<div id="admonition-osi-the-internet-that-wasnthttpsspectrumieeeorgosi-the-internet-that-wasnt" class="admonition admonish-info">
<div class="admonition-title">
<p><a href="https://spectrum.ieee.org/osi-the-internet-that-wasnt">osi the internet that wasnt</a></p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-osi-the-internet-that-wasnthttpsspectrumieeeorgosi-the-internet-that-wasnt"></a></p>
</div>
<div>
<p>TLDR: OSI y TCP/IP compitieron durante un tiempo, pero una de las mayores
diferencias radicaba en que OSI era un protocolo que se estaba gestando por un
comit√© conformado por gente de la industria y cada uno quer√≠a tener su
influencia sobre el protocolo. Esto result√≥ en problemas para ponerse de
acuerdo y en un modelo que si bien era completo era mucho m√°s dif√≠cil de
implementar, m√°s caro y complejo.</p>
<p>Mientras segu√≠an discutiendo sobre el est√°ndar de OSI, TCP/IP ya se estaba usando...</p>
</div>
</div>
<h2 id="nivel-f√≠sico"><a class="header" href="#nivel-f√≠sico">Nivel F√≠sico</a></h2>
<h3 id="sistema-de-comunicaciones"><a class="header" href="#sistema-de-comunicaciones">Sistema de Comunicaciones</a></h3>
<p>Modelo: tengo fuente de info -&gt; Emisor -&gt; ----- canal de comunicaci√≥n ----- -&gt; Receptor -&gt; Destino</p>
<ul>
<li>Qu√© es informaci√≥n?</li>
<li>Qu√© es un canal?
<ul>
<li>guiado (cable)</li>
<li>no guiado (inal√°mbrico)</li>
</ul>
</li>
<li><strong>Siempre</strong> me ingresa ruido (alto o bajo)</li>
</ul>
<div id="admonition-ejemplo" class="admonition admonish-info">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-ejemplo"></a></p>
</div>
<div>
<p>Hablo en meet y tengo a mi gato maullando. Tengo que hablar m√°s fuerte. M√°s
fuerte = mejor? Bueno no, lo que importa es la relaci√≥n entre cu√°nto grito y el
ruido ambiente.</p>
</div>
</div>
<ul>
<li>Relaci√≥n Se√±al / Ruido</li>
<li>La se√±al tiende a atenuarse a mayor distancia. Si se achica la se√±al y el
ruido es constante, entonces se achica la capacidad de transmisi√≥n tambi√©n.</li>
<li>Lo importante de se√±al:
<ul>
<li>Es una onda electromagn√©tica</li>
<li>Se propaga a la velocidad de la luz (a un ~70% de la velocidad de la luz en el vac√≠o)</li>
<li><em>Demora</em>, no es instant√°neo (es un l√≠mite f√≠sico, no lo puedo evitar)
<ul>
<li><strong>Tiempo de propagaci√≥n</strong></li>
<li>RTT (Round Trip Time) entre USA y ARG = 100ms</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Frecuencia \(f\) = Cantidad de ciclos que entran en un segundo</p>
<p>Longitud de onda \(\lambda\) = \(c\) (velocidad de la luz) \(/ f\)</p>
<ul>
<li>a mayor frecuencia menor longitud de onda (\(c\) es constante)</li>
</ul>
<p>Glosario:</p>
<ul>
<li>Amplitud</li>
<li>Frecuencia Angular (= \(2 \pi f\))</li>
<li>Frecuencia Temporal (\(f\))</li>
<li>Per√≠odo = \(\frac{1}{f}\)</li>
<li>Fase (desplazamiento)</li>
</ul>
<h3 id="dominio-transformado"><a class="header" href="#dominio-transformado">Dominio Transformado</a></h3>
<p>Lo anterior era orientado al dominio del tiempo. Idea: paso ese dominio a otro para procesarlo mejor:</p>
<ul>
<li>serie trigonom√©trica de fourier -&gt; puedo representar ordas cuadradas como una serie infinita de senos y cosenos
<ul>
<li>permite descomponer la se√±al en las distintas frecuencias</li>
</ul>
</li>
<li>transformada de fourier
<ul>
<li>lo anterior en la teor√≠a. Esto en la pr√°ctica</li>
<li>esto es lo que en la pr√°ctica permite descomponer una se√±al en sus distintas arm√≥nicas / componentes de frecuencia</li>
</ul>
</li>
</ul>
<h3 id="ancho-de-banda"><a class="header" href="#ancho-de-banda">Ancho de banda</a></h3>
<p>Rango de frecuencias senoidales que pueden pasar por el medio sin ser atenuadas (&lt; 3db, esto es una generalizaci√≥n).</p>
<div id="admonition-pregunta-de-final" class="admonition admonish-warning">
<div class="admonition-title">
<p>Pregunta de Final</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-pregunta-de-final"></a></p>
</div>
<div>
<p>Tengo ancho de banda de 0 a 4 khz. Meto onda cuadrada peri√≥dica de 3khz en un canal con ancho de banda de 0 a 4khz. Qu√© obtengo a la salida?</p>
<p>Rta: Obtengo una onda senoidal de 3khz, porque la primera arm√≥nica tiene el
triple de frecuencia que la fundamental (en este caso es de 3 y la arm√≥nica ya
tiene 9), o sea que salvo la fundamental te filtra todo.</p>
</div>
</div>
<h3 id="teor√≠a-de-la-informaci√≥n"><a class="header" href="#teor√≠a-de-la-informaci√≥n">Teor√≠a de la informaci√≥n</a></h3>
<p>(En el 48') Llega Shannon con su paper "A Mathematical Theory of
Communication". √çdolo, Genio, Maestro, Crack.</p>
<p>Idea fundamental:</p>
<ul>
<li>No interesa el significado del mensaje (No me importa si es tel√©fono, tele, internet, etc.)</li>
<li><strong>Teor√≠a Cl√°sica de la informaci√≥n</strong></li>
<li>Propone 2 teoremas fundamentales:
<ul>
<li>Codificaci√≥n para una fuente sin ruido</li>
<li>Codificaci√≥n para un canal con ruido</li>
</ul>
</li>
<li>Sorprendentemente nunca habla de c√≥mo implementar nada</li>
</ul>
<p>Definici√≥n: qu√© es la informaci√≥n</p>
<p>$$
I(E) = log(\frac{1}{P(E)})
$$</p>
<p>La informaci√≥n que me da un evento es el logaritmo de la inversa de la
probabilidad de que ese evento suceda.</p>
<p><strong>Unidades</strong>:</p>
<ul>
<li>log en base 2? <em>1 bit</em> (por qu√©? Si tengo un d√≠gito binario equiprobable \(I(\)sale 0/1\() = 1\)</li>
<li>(hay otros)</li>
</ul>
<h3 id="fuente-de-memoria-nula"><a class="header" href="#fuente-de-memoria-nula">Fuente de Memoria Nula</a></h3>
<p>Es el modelo que tomamos asumiendo que cada s√≠mbolo que emite es estad√≠sticamente independiente del siguiente</p>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-info"></a></p>
</div>
<div>
<p>Con una fuente de memoria nula, \(E(s_i) = log(\frac{1}{P(s_i)})\) bits</p>
</div>
</div>
<h3 id="entrop√≠a"><a class="header" href="#entrop√≠a">Entrop√≠a</a></h3>
<p>Viene a representar algo as√≠ como la cantidad media de info por s√≠mbolo de la fuente (similar a Esperanza).</p>
<p>$$
\sum_S P(s_i)I(s_i) \text{  bits}
$$</p>
<p>Es algo como la cantidad de info que voy a obtener cuando observo un s√≠mbolo / evento.</p>
<p>Cu√°ndo maximizo la info que me van a dar los eventos? Cuando los eventos son equiprobables.</p>
<div id="admonition-offtopic-recomendaci√≥n" class="admonition admonish-info">
<div class="admonition-title">
<p>offtopic recomendaci√≥n</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-offtopic-recomendaci√≥n"></a></p>
</div>
<div>
<p>3b1b tiene un video en el que habla de entrop√≠a y lo aplica al wordle</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/v68zYyaEmEA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
</div>
<h3 id="extensi√≥n-de-la-fuente-de-memoria-nula"><a class="header" href="#extensi√≥n-de-la-fuente-de-memoria-nula">Extensi√≥n de la Fuente de Memoria Nula</a></h3>
<p>En vez de considerar de a un bit, agrupo varios bits juntos</p>
<h3 id="codificaci√≥n"><a class="header" href="#codificaci√≥n">Codificaci√≥n</a></h3>
<p>Codificaci√≥n ser√≠a el proceso por el cual mappeamos los s√≠mbolos de la fuente a
s√≠mbolos de un alfabeto asociado. Por qu√© hacemos esto? En primer lugar porque
a veces no tenemos una representaci√≥n sencilla con la que trabajar. Y segundo
porque dependiendo el tipo de codificaci√≥n que usemos vamos a obtener una mejor
o peor eficiencia.</p>
<ul>
<li>Le decimos <strong>c√≥digo bloque</strong> a una codificaci√≥n que asigna cada s√≠mbolo de la
fuente a una secuencia de s√≠mbolos del alfabeto destino.</li>
<li>Si la codificaci√≥n es una funci√≥n <strong>inyectiva</strong>, decimos que la codificaci√≥n
es <strong>no singular</strong></li>
<li>Y decimos que una codificaci√≥n es <strong>un√≠vocamente decodificable</strong> si ninguna
tira de s√≠mbolos del c√≥digo (o sea los c√≥digos generados) admite m√°s de una
√∫nica decodificaci√≥n.</li>
<li>Por √∫ltimo, dec√≠mos que un c√≥digo es <strong>instant√°neo</strong> si es posible
decodificar sin ver los s√≠mbolos que suceden (no tiene que hacer look ahead)</li>
</ul>
<div id="admonition-condicion-de-los-prefijos" class="admonition admonish-info">
<div class="admonition-title">
<p>condicion de los prefijos</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-condicion-de-los-prefijos"></a></p>
</div>
<div>
<p>Una condici√≥n <strong>necesaria y suficiente</strong> para que un c√≥digo sea
<strong>instant√°neo</strong>, es que no haya palabra en el alfabeto que sea prefijo de la
misma. Ojo, dos palabras pueden tener un mismo prefijo com√∫n siempre que el
mismo no pertenezca al alfabeto.</p>
<p>Teorema: Instant√°neo =&gt; un√≠vocamente decodificable</p>
</div>
</div>
<ul>
<li>En ascii tenemos 8 digitos binarios por s√≠mbolo</li>
<li>Sin embargo, en morse tenemos una cantidad variable</li>
</ul>
<p>Pensemos ahora que lo que mandamos son mensajes, y para representar cada
mensaje (\(m_i\)) lo representamos con una palabra de longitud \(L_i\). Y
nuestro s√≠mbolo se codifica con cadenas de un alfabeto de \(r\) s√≠mbolos.</p>
<p>Para esto √∫ltimo se define la <strong>longitud media de un c√≥digo</strong>. Es la
probabilidad de ocurrencia de cada s√≠mbolo por su longitud. Ser√≠a como la
esperanza de la longitud de recibir un s√≠mbolo, o algo as√≠.</p>
<p>$$
L = \sum{p_i L_i}
$$</p>
<p>C√≥mo lo minimizo? Al que m√°s probabilidad tenga, le doy el c√≥digo m√°s chico.</p>
<p>Otra cosa m√°s, es que para asegurar que no haya p√©rdida de informaci√≥n requiero
que:</p>
<p>$$
L log(r) \geq H(S)
$$</p>
<p>Donde \(log(r)\) es la cantidad promedio m√°xima de info de un s√≠mbolo del c√≥digo (por lo que vimos antes).</p>
<p>Definimos con esa desigualdad la <strong>eficiencia de un c√≥digo</strong> \(h\) como:</p>
<p>$$
h = \frac{H(s)}{L log(r)}
$$</p>
<p>y \(h_{max} = 1\)</p>
<h3 id="codificaci√≥n-de-huffmann"><a class="header" href="#codificaci√≥n-de-huffmann">Codificaci√≥n de Huffmann</a></h3>
<p>Es un m√©todo que permite construir codificadores √≥ptimos en base a la
frecuencia en la que aparecen los s√≠mbolos (de la fuente).</p>
<h2 id="medios-de-transmisi√≥n-reales"><a class="header" href="#medios-de-transmisi√≥n-reales">Medios de Transmisi√≥n Reales</a></h2>
<p>Cualquier canal de comunicaci√≥n:</p>
<ul>
<li>Est√° expuesto a ruido</li>
<li>Tiene problemas de potencia</li>
<li>Tienen problemas de ancho de banda</li>
</ul>
<h3 id="f√≥rmula-de-capacidad-de-shannon-para-un-canal-sujeto-a-ruido"><a class="header" href="#f√≥rmula-de-capacidad-de-shannon-para-un-canal-sujeto-a-ruido">F√≥rmula de capacidad de Shannon para un canal sujeto a ruido</a></h3>
<p>$$
C_max(bps) = B(\text{hz}) log_2(1 + \text{SNR})
$$</p>
<div id="admonition-snr-para-capacidad-de-shannon" class="admonition admonish-info">
<div class="admonition-title">
<p>SNR para capacidad de Shannon</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-snr-para-capacidad-de-shannon"></a></p>
</div>
<div>
<p>La relaci√≥n se√±al-ruido de la capacidad de Shannon se expresa como logaritmos:</p>
<p>$$
SNR_{db} = 10 log_{10}(\text{SNR}) = 10 log_{10}(\frac{\text{PotenciaSe√±al}}{\text{PotenciaRuido}})
$$</p>
<p>Por qu√© la escala logar√≠tmica?</p>
<p>Es para ajustarse a las magnitudes. La atenuaci√≥n es logar√≠tmica, el oido tiene
respuesta logar√≠tmica, etc. Y la escala logar√≠tmica resulta m√°s pr√°ctico (sobre
todo para visualizar)</p>
</div>
</div>
<h3 id="intro-a-nyquist"><a class="header" href="#intro-a-nyquist">Intro a Nyquist</a></h3>
<p>El √±ato este tir√≥ una f√≥rmula para la capacidad m√°xima en canales <strong>sin ruido</strong>:</p>
<ul>
<li>
<p>2 niveles:
$$
C = 2B(\text{Hz})
$$</p>
</li>
<li>
<p>\(M\) niveles:
$$
C = 2B(\text{Hz})log_2(M)
$$</p>
</li>
</ul>
<p>Sin embargo hay una restricci√≥n, \(M\) tiene que ser m√°s chico que \(\sqrt(1 + \text{SNR})\)</p>
<div id="admonition-pregunta-de-final-alert" class="admonition admonish-warning">
<div class="admonition-title">
<p>Pregunta de final alert</p>
<p><a class="admonition-anchor-link" href="unidad_0.html#admonition-pregunta-de-final-alert"></a></p>
</div>
<div>
<p><strong>Qu√© es el delay?</strong></p>
<p>Est√° formado por:</p>
<ul>
<li>el tiempo de propagaci√≥n</li>
<li>el tiempo de transmisi√≥n</li>
<li>el tiempo de encolamiento</li>
<li>el tiempo de procesamiento</li>
</ul>
<p>Notar que s√≥lo el tiempo de propagaci√≥n ya te puede estar limitando porque
transmitimos casi a la velocidad de la luz y sin embargo para mandar 1 bit por
10000km por fibra tengo un tiempo de propagaci√≥n aproximado de 50ms (y por lo
tanto 100ms de RTT).</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-1---nivel-f√≠sico"><a class="header" href="#unidad-1---nivel-f√≠sico">Unidad 1 - Nivel F√≠sico</a></h1>
<p>La f√≥rmula de Shannon pone un l√≠mite en la tasa de transmisi√≥n, pero no en la
probabilidad de error. En teor√≠a se podr√≠a minimizar arbitrariamente la
probabilidad de error usando una codificaci√≥n lo suficientemente combleja y
obviamente con \(R_b \leq C\). Al no cumplir esto √∫ltimo esa idea de
minimizar la probabilidad de error arbitrariamente ya no es posible.</p>
<p><img src="./img/shannon_limit_graph.png#center" alt="Gr√°fico de SNR en base a la relaci√≥n de la capacidad y el ancho de banda" /></p>
<p>Si graficamos la relaci√≥n entre la SNR y la relaci√≥n capacidad sobre ancho de
banda obtenemos el gr√°fico de arriba, que de alguna forma nos da valores para
lo que es posible y lo que no. En la pr√°ctica se busca asemejarse lo m√°s
posible a la funci√≥n graficada, buscando aumentar la cantidad de bits/s.</p>
<div id="admonition-pregunta-de-final" class="admonition admonish-warning">
<div class="admonition-title">
<p>pregunta de final</p>
<p><a class="admonition-anchor-link" href="unidad_1.html#admonition-pregunta-de-final"></a></p>
</div>
<div>
<p>Tengo un canal de ancho de banda de 0 a 2 Mhz, cu√°l es la forma de la onda de
salida si inyecto una se√±al de 1 Mhz. S√≥lamente obtengo la fundamental ya que a
partir de la tercer arm√≥nica que no entra en el ancho de banda.</p>
</div>
</div>
<h2 id="medios-de-transmisi√≥n"><a class="header" href="#medios-de-transmisi√≥n">Medios de transmisi√≥n</a></h2>
<p>Hoy en d√≠a tenemos internet compuesta por provedores que tiene tecnolog√≠as de acceso:</p>
<ul>
<li>Fibra</li>
<li>Cable</li>
<li>Sat√©lite</li>
<li>Wifi</li>
<li>Celular</li>
</ul>
<p><img src="./img/internet_diagram.png#center" alt="Gr√°fico de organizaci√≥n de Internet" /></p>
<p>Las ondas electromagn√©ticas "necesitan" (en realidad no necesitan nada, se
pueden propagar por el vac√≠o) un <strong>medio de transmisi√≥n</strong> por el cu√°l
transmitirse. Pueden ser:</p>
<ul>
<li>Guiados: Cable
<ul>
<li>de cobre</li>
<li>coaxil</li>
<li>fibra √≥ptica</li>
</ul>
</li>
<li>No guiados: El espacio, libre
<ul>
<li>por radio</li>
<li>microondas</li>
<li>ondas infrarojas</li>
<li>laser</li>
<li>sat√©lite</li>
<li>luz</li>
</ul>
</li>
</ul>
<h2 id="red-telef√≥nica"><a class="header" href="#red-telef√≥nica">Red telef√≥nica</a></h2>
<p>Vamos a tomar de ejemplo a la red telef√≥nica ya que muchos de los conceptos se
replican en otros medios de tecnolog√≠as.</p>
<ul>
<li>mediante conmutaci√≥n de circuitos</li>
</ul>
<h3 id="multiplexaci√≥n"><a class="header" href="#multiplexaci√≥n">Multiplexaci√≥n</a></h3>
<p>Multiplexar consiste en poder tener varias comunicaciones simult√°neas en un
mismo troncal f√≠sico.</p>
<p>Podemos multiplexar:</p>
<ul>
<li>por tiempo: una suerte de round robin</li>
<li>por divisi√≥n frecuencia: transmito a trav√©s de las distintas bandas
<ul>
<li>el circuito para esto suele ser m√°s complejo</li>
<li>al tener menos ancho de banda es "m√°s lento", pero tengo m√°s uptime</li>
</ul>
</li>
<li>por divisi√≥n de onda: lo mismo que antes pero aplicado a sistemas √≥pticos</li>
</ul>
<p><img src="./img/multiplexation_time_vs_freq.png#center" alt="Multiplexaci√≥n por Frecuencia vs Tiempo" /></p>
<h2 id="taxonom√≠a-de-redes"><a class="header" href="#taxonom√≠a-de-redes">Taxonom√≠a de Redes</a></h2>
<p>Las Redes de comunicaciones se pueden dividir en:</p>
<ul>
<li>Redes de conmutaci√≥n de Circuitos</li>
<li>Redes de conmutaci√≥n de Paquetes
<ul>
<li>Redes con Circuitos Virtuales</li>
<li>Redes de Datagramas (en el 99.999% de la materia vemos esto)
<ul>
<li>servicio sin conexi√≥n</li>
<li>el nivel de transporte brinda soporte para dar servicio orientado a conexi√≥n tambi√©n (ej: TCP)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Las redes de conmutaci√≥n de paquetes se basan en el concepto de
<strong>multiplexaci√≥n estad√≠stica</strong>. Mi conmutador tiene un buffer y despacha de a
poco en base a alg√∫n criterio en base a la direcci√≥n origen y destino de dichos
paquetes.</p>
<p>Esta idea tambi√©n implica que cada paquete compite con otros por ser enviado y
puede llevarnos a situaciones de congesti√≥n.</p>
<h2 id="conversi√≥n-anal√≥gico-digital"><a class="header" href="#conversi√≥n-anal√≥gico-digital">Conversi√≥n Anal√≥gico Digital</a></h2>
<p>Tengo 2 Etapas:</p>
<ol>
<li>Primero una etapa de muestreo
<ul>
<li>Gracias a Nyquist sabemos que debemos muestrear al doble del ancho de banda (por lo menos)</li>
<li>Adem√°s, tengo que definir con cu√°ntos d√≠gitos binarios uso para representar cada muestra</li>
</ul>
</li>
<li>Segundo cuantifico dichas muestras (o sea mando el valor a su representaci√≥n binaria correspondiente)
<ul>
<li>Hoy en d√≠a a esa t√©cnica la llamamos <em>PCM</em> (<strong>P</strong>ulse <strong>C</strong>ode <strong>M</strong>odulation)</li>
</ul>
</li>
</ol>
<h3 id="teorema-del-muestreo-nyquist"><a class="header" href="#teorema-del-muestreo-nyquist">Teorema del muestreo (Nyquist)</a></h3>
<p>Si queremos Reconstruir una se√±al cuya frecuencia m√°xima es \(f_m\) debemos
muestrar dicha se√±al a una raz√≥n de \(f_s &gt; 2 * f_m\) llamada <strong>frecuencia de
muestreo</strong></p>
<div id="admonition-ejemplo-con-red-de-computadoras" class="admonition admonish-info">
<div class="admonition-title">
<p>Ejemplo con red de computadoras</p>
<p><a class="admonition-anchor-link" href="unidad_1.html#admonition-ejemplo-con-red-de-computadoras"></a></p>
</div>
<div>
<p><img src="./img/modem_and_codec.png#center" alt="" /></p>
<p>Este es un diagrama (un poco antiguo). Las oficinas interurbanas operaban en
digital, por lo que era necesario que la se√±al originalmente anal√≥gica sea
convertida a una se√±al digital.</p>
<p>Uno en casa entonces ten√≠a un modem, que emit√≠a una se√±al anal√≥gica y luego le
segu√≠a un codec que se encargaba de hacer la conversi√≥n anal√≥gico digital. Del
otro lado de la red, estaba un codec que cumpl√≠a la funci√≥n inversa y un modem
por cliente.</p>
<p>Si lo pensamos con el caso del tel√©fono, la mayor√≠a de las comunicaciones por
voz se pueden agrupar en el rando de 0-4Khz, por lo tanto se necesita una tasa
de muestreo de 8Khz o 8000 muestras por segundo. Como en ese caso cada muestra
se codificaba en 8 bits (En realidad son 7 bits para la data y 1 para
sincronizaci√≥n), era necesario un ancho de banda (I know, est√° mal usar este
t√©rmino) de 64kbps.</p>
</div>
</div>
<h2 id="modulaci√≥n"><a class="header" href="#modulaci√≥n">Modulaci√≥n</a></h2>
<h3 id="frecuencia-modulada-vs-amplitud-modulada"><a class="header" href="#frecuencia-modulada-vs-amplitud-modulada">Frecuencia Modulada vs Amplitud Modulada</a></h3>
<p><img src="./img/am_vs_fm.png" alt="" /></p>
<p>Tengo la Se√±al Portadora y la Se√±al Modulante.</p>
<ul>
<li>Frecuencia Modulada es cuando la frecuencia de la portadora var√≠a en base a la amplitud de la modulante.</li>
<li>Amplitud Modulada es cuando la amplitud de la portadora var√≠a en base a la amplitud de la modulante.</li>
</ul>
<h3 id="modem"><a class="header" href="#modem">Modem</a></h3>
<p>Si volvemos al diagrama, la idea del modem era transformar la se√±al digital de
la computadora en una se√±al anal√≥gica para poder mandarla por los cables de
cobre (y posteriormente volver a ser convertida a digital por el codec ü§∑).</p>
<p>El truco de los modems entonces es meter la informaci√≥n sobre una se√±al portadora que pueda pasar por el ancho de banda disponible. Para esto hay 3 t√©cnicas de modulaci√≥n de una se√±al digital sobre una anal√≥gica:</p>
<ul>
<li>Desplazamiento de amplitud (ASK)</li>
</ul>
<p><img src="./img/ask.png#center" alt="" /></p>
<ul>
<li>Desplazamiento de frecuencia (FSK)</li>
</ul>
<p><img src="./img/fsk.png#center" alt="" /></p>
<ul>
<li>Desplazamiento de fase (PSK)</li>
</ul>
<p><img src="./img/psk.png#center" alt="" /></p>
<ul>
<li>
<p><strong>Velocidad de Modulaci√≥n</strong> \(V_m\): es el n√∫mero de cambios de se√±al por unidad de
tiempo. Se mide en Baudios (s√≠mbolos / segundo).</p>
</li>
<li>
<p><strong>Velocidad de Transmisi√≥n</strong>: \(V_m * N\), donde \(N\) es el n√∫mero de
bits por s√≠mbolo. Se mide en bits por segundo.</p>
</li>
</ul>
<h3 id="lets-go-even-further"><a class="header" href="#lets-go-even-further">Let's go even further</a></h3>
<blockquote>
<p>Recomendaci√≥n: si tienen dudas lean esta parte del Tanenbaum, en el Peterson no est√°.</p>
</blockquote>
<p>Vieron que dijimos que la velocidad de Modulaci√≥n la medimos en s√≠mbolos por
segundo, y no en base a la cantidad de bits. Bueno, tranquilamente podemos
asumir que no tengo un √∫nico canal binario si no muchos (varios bits), y la
combinaci√≥n son los distintos s√≠mbolos a transferir.</p>
<p>Luego, lo que puedo hacer es modular para 2 bits en base a 4 frecuencias o 4 fases (QPSK) por
ejemplo. Esto es lo que se conoce como modulaci√≥n multinivel.</p>
<p>Tambi√©n puedo combinar amplitud y fase (QAM) o amplitud y frecuencia (no puedo ambos
porque fase y frecuencia est√°n relacionados). (hoy en d√≠a ya estamos llegando a 1024-QAM y 4096-QAM)</p>
<p><img src="./img/qpsk_and_gam.png#center" alt="" /></p>
<p>Y puedo agregar tantos niveles como quiera, pero fijate que a medida que agrego
m√°s puntos, hago m√°s finita la cuadratura. Con lo cual es m√°s vulnerable al
ruido.</p>
<p>El error generado se llama <em>MER</em>, y se expresa en db como:</p>
<p>$$
\text{MER} = 10 log \frac{\text{RMS error magnitude}}{\text{average symbol magnitude}}
$$</p>
<div id="admonition-dato-de-color-sobre-wi-fi" class="admonition admonish-info">
<div class="admonition-title">
<p>Dato de color sobre Wi-Fi</p>
<p><a class="admonition-anchor-link" href="unidad_1.html#admonition-dato-de-color-sobre-wi-fi"></a></p>
</div>
<div>
<p>A medida que me alejo del router y pierdo se√±al, aumenta la <em>SNR</em> y por ende me
cuesta m√°s distinguir cada s√≠mbolo de QAM. Entonces lo que hace Wi-Fi es
achicar la cantidad de s√≠mbolos y por ende baja de QAM-1024 (ponele) a QAM-256,
y por ende baja su velocidad para evitar errores en la transmisi√≥n.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-2---nivel-de-enlace"><a class="header" href="#unidad-2---nivel-de-enlace">Unidad 2 - Nivel de Enlace</a></h1>
<p>Tanto OSI como TCP usan un modelo basado en <em>capas</em>. Cada Entidad separa su
funcionalidad en varias capas. Cada capa agrega info de control, mediante el
agregado de headers. De esta forma la capa agrega / interpreta los headers o
frames enviados / recibidos y permite que haya una comunicaci√≥n entre las capas
adyacentes pero a su vez capa a capa entre los distintos hosts.</p>
<p><img src="./img/control_info.png" alt="" /></p>
<p>Adem√°s, el servicio que una capa le brinda a otra se puede clasificar en:</p>
<ul>
<li><strong>sin conexi√≥n y sin reconocimiento</strong> (ej: UDP)</li>
<li><strong>sin conexi√≥n y con reconocimiento</strong> (ej: uso de ACK en capa 2 de OSI)</li>
<li><strong>orientado a conexi√≥n</strong> (ej: websockets, TCP)</li>
</ul>
<p>El objetivo de los protocolos de comunicaci√≥n (nivel de enlace en OSI), buscan en proveer:</p>
<ul>
<li>confiabilidad</li>
<li>control de errores</li>
<li>control de flujo</li>
</ul>
<p>Un ejemplo para garantizar control de errores ser√≠a agregar un CRC / checksum
que el receptor valida. Si el receptor detecta que el mensaje es inv√°lido,
basta con que no mande un ACK (aknowledge) de que recibi√≥ el mensaje.</p>
<h2 id="control-de-errores"><a class="header" href="#control-de-errores">Control de errores</a></h2>
<p>Si consideramos que lo que mandamos son <em>codewords</em> de \(n\) bits, compuestos
por \(m\) bits de datos y \(r\) bits de redundancia y siendo \(d\) la
distancia m√≠nima de Hamming entre 2 codewords posibles y \(e\) la cantidad de
bits erroneos para un cierto mensjae, necesitamos que se cumpla que:</p>
<ul>
<li>\(e + 1 \leq d\) para poder detectar que hubo errores</li>
<li>\(2*e + 1 \leq d\) para poder corregir errores</li>
</ul>
<blockquote>
<p>Si quieren ver un algoritmo para detecci√≥n y correcci√≥n de errores pueden
chequear
<a href="https://www.cs.cmu.edu/~guyb/realworld/reedsolomon/reed_solomon_codes.html">Reed-Solomon</a></p>
</blockquote>
<h2 id="confiabilidad"><a class="header" href="#confiabilidad">Confiabilidad</a></h2>
<p>Para garantizar confiabilidad, va a ser necesario poder efectuar
<em>retransmisiones</em>. Esto se puede dar de forma <strong>impl√≠cita</strong> cuando se produce
un <strong>timeout</strong> (tiempo sin recibir un ACK de que se recibi√≥ el mensaje), o de
forma <strong>expl√≠cita</strong> si nuestro protocolo admite mensajes de control.</p>
<p>C√≥mo puedo hacer el ACK de cierto s√≠mbolo? Mediante n√∫meros de secuencia. El
ACK entonces representa que el frame con cierto n√∫mero de secuencia fue
recibido.</p>
<h3 id="primer-approach-stop-and-wait"><a class="header" href="#primer-approach-stop-and-wait">Primer approach: Stop and Wait</a></h3>
<ul>
<li>Espero a recibir el ACK para mandar el nuevo frame.</li>
<li>Dado que es "bloqueante", basta con tener un √∫nico bit para el n√∫mero de secuencia.</li>
</ul>
<p>Qu√© pasa si ocurre lo siguiente:</p>
<ol>
<li>El emisor manda el primer frame</li>
<li>Transcurre el tiempo suficiente para que ocurra un timeout (en el medio el
Receptor recibe el frame pero no responde a tiempo)</li>
<li>El emisor vuelve a mandar el primer frame</li>
<li>El emisor recibe el ACK del primer frame</li>
<li>El receptor recibe el primer frame y manda el ACK</li>
<li>El emisor recibe por segunda vez el ACK del primer frame</li>
</ol>
<p>Ese fen√≥meno es lo que se conoce como el <strong>problema del solapamiento</strong> o el
<strong>problema de las reencarnaciones</strong>, y los distintos approaches van a buscar
problemas de lidiar con esto.</p>
<h3 id="eficiencia-de-un-protocolo"><a class="header" href="#eficiencia-de-un-protocolo">Eficiencia de un protocolo</a></h3>
<p>Queremos evaluar cu√°nto tiempo se est√° transmitiendo vs cu√°nto tiempo se est√°
esperando por confirmaciones. Lo definimos como:</p>
<p>$$
\eta_{proto} = \frac{T_{tx}}{\text{RTT}(F)}
$$</p>
<blockquote>
<p>Pregunta: Tiene sentido que \(\eta_{proto} &gt; 1\)?</p>
</blockquote>
<h3 id="segundo-approach-ventana-deslizante"><a class="header" href="#segundo-approach-ventana-deslizante">Segundo approach: Ventana deslizante</a></h3>
<p>Para el caso de Stop and Wait, notar que transmito la mitad de lo que dura el
RTT y despu√©s espero, entonces tengo una eficiencia del 0,5. Queremos hacerlo
mejor.</p>
<p>Idea: mando varios frames seguidos, sin esperar al ACK. Esto es el concepto de
<strong>ventana de frames</strong>, y en ese caso el c√°lculo de la eficiencia cambia
ligeramente:</p>
<p>$$
\eta_{proto} = \frac{T_{tx}(V)}{\text{RTT}(F)}
$$</p>
<p>Ahora el \(T_{tx}(V)\) es el tiempo que me tarda mandar todos los frames de
la ventana, mientras que el \(\text{RTT}(F)\) es lo que tarda en volverme el
ACK del primer frame que mand√©.</p>
<ul>
<li>Requiero de m√°s bits para el n√∫mero de secuencia (tiene que permitirme
identificar todos los frames de la trama por lo menos)</li>
<li>A medida que recibo los ACk voy desplazando la ventana (ojo porque ahora hay
que determinar cu√°ndo desplazo la ventana. Siempre que recibo? O s√≥lo si
recib√≠ el siguiente al √∫ltimo que ten√≠a reconocido?)</li>
</ul>
<p>Para buscar la mejor eficiencia posible se define como tama√±o de ventana (en
frames) a:</p>
<p>$$
\text{SWS} = \frac{V_{tx} * RTT}{|Frame|}
$$</p>
<p>Y env√≠o un frame nuevo siempre que \(\text{UltimoFrameEnviado} \leq \text{UltimoFrameReconocido} + \text{SWS}\)</p>
<h3 id="acks-acumulativos-vs-selectivos"><a class="header" href="#acks-acumulativos-vs-selectivos">ACKs acumulativos vs selectivos</a></h3>
<p>En la secci√≥n anterior falt√≥ mencionar cu√°l es el comportamiento esperado del
receptor ante alg√∫n error. El primer approach es el de ACKs acumulativos, en
donde a partir de que se produce un error en la transmisi√≥n el receptor ignora
todos los mensajes posteriores hasta que el frame con error se reenv√≠a y recibe
correctamente. (Esta idea de retransmitir todo se lo conoce tambi√©n como
<strong>GoBackN</strong>)</p>
<p><img src="./img/sliding_window_gobackn.png#center" alt="" /></p>
<p>Ahora, tambi√©n podr√≠a pedir que el receptor tenga un buffer que permita guardar
los frames que va recibiendo, y en ese caso basta con que el receptor mande una
se√±al pidiendo el frame espec√≠fico.</p>
<p><img src="./img/sliding_window_sack.png#center" alt="" /></p>
<p>Para ambos casos definimos la ventana de recepci√≥n \(\text{RWS}\) como:</p>
<p>$$
\text{RWS} =
\begin{cases}
\text{SWS},  &amp; \text{si hay SACK} \\
1, &amp; \text{en caso contrario}
\end{cases}
$$</p>
<p>Adem√°s, como se puede dar ac√° tambi√©n el problema de las reencarnaciones, es
necesario poder distinguir por lo menos \(SWS + RWS\) frames distintos.</p>
<h3 id="sobre-la-eficiencia-de-la-ventana"><a class="header" href="#sobre-la-eficiencia-de-la-ventana">Sobre la eficiencia de la ventana</a></h3>
<p>Primero necesito que definamos algunos conceptos:</p>
<ul>
<li>El <strong>tiempo de transmisi√≥n</strong> \(T_{tx} = \frac{|datos|}{V_{tx}}\) es el
tiempo para enviar todos los bits de un frame a trav√©s del medio de
transmisi√≥n.
<ul>
<li>Ocupa una porci√≥n significativa de tiempo en conexiones lentas o donde el
frame es muy grande.</li>
</ul>
</li>
<li>El <strong>tiempo de propagaci√≥n</strong> \(T_{prop} = \frac{distancia}{V_{prop}}\) es
el tiempo desde que el bit es transmitido hasta que llega al receptor.
<ul>
<li>La velocidad de propagaci√≥n \(V_{prop}\) es algo propio del medio de
transmisi√≥n, por lo general cercano a la velocidad de la luz (suele ser
una constante multiplicada por la velocidad de la luz).</li>
<li>Ocupa una porci√≥n significativa de tiempo en conexiones entre dos puntos
muy lejanos.</li>
</ul>
</li>
<li>El <strong>tiempo de encolamiento</strong> \(T_{queue}\) es el tiempo que espera un
frame en un buffer hasta ser transmitido. Dependiendo del estado de
congesti√≥n de la red puede ser significativo o no.</li>
<li>El <strong>tiempo de procesamiento</strong> \(T_{proc}\) es el tiempo que se tarda en
leer el header de un frame y decidir qu√© hacer con √©l. En la pr√°ctica se lo
asume nulo o poco significativo.</li>
</ul>
<p>Por √∫ltimo, la <strong>capacidad de volumen</strong> \(C_{vol}\) de un canal ser√≠a la cantidad de bits
que entran en el canal desde que se env√≠a el primer bit hasta que llega al
receptor (una suerte de flujo m√°ximo de bits para quienes hayan cursado algo
III).</p>
<p>$$
C_{vol} = \text{Delay} * V_{tx}
$$</p>
<p>Sin embargo, para los protocolos punto a punto se es un poco m√°s
espec√≠fico y se mide como la cantidad de bits que entran <strong>hasta recibir el
primer ACK</strong></p>
<p>$$
C_{vol} = \text{RTT} * V_{tx}
$$</p>
<p>(Recuerdo: antes mencionamos que el tama√±o √≥ptimo de ventana era \(SWS = \frac{\text{RTT} * V_{tx}}{|frame|} = \frac{C_{vol}}{|frame|}\))</p>
<p>Entonces... ¬øPor qu√© es √≥ptimo?</p>
<p>Recordamos que la eficiencia del protocolo de ventana deslizante se med√≠a como:</p>
<p>$$
\eta_{proto} = \frac{T_{tx}(V)}{\text{RTT}(F)}
$$</p>
<p>\(T_{tx}(V)\) Era el tiempo que tardaba en mandar todos los frames de la ventana. Eso lo podemos pensar como:</p>
<p>$$
T_{tx}(V) = \frac{SWS * |frame|}{V_{tx}}
$$</p>
<p>Entonces:</p>
<p>$$
\eta_{proto} = \frac{SWS * |frame|}{V_{tx} * \text{RTT}(F)} \\
SWS = \eta_{proto} * \frac{V_{tx} * \text{RTT}(F)}{|frame|}
$$</p>
<p>Y asumiendo que \(\eta_{proto} = 1\) dado que es √≥ptimo obtenemos que:</p>
<p>$$
SWS = \frac{V_{tx} * \text{RTT}(F)}{|frame|}
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-3---medios-compartidos"><a class="header" href="#unidad-3---medios-compartidos">Unidad 3 - Medios Compartidos</a></h1>
<p>Antes vimos que se pod√≠a compartir un canal de transmisi√≥n mediante t√©cnicas
como la multiplexaci√≥n por tiempo o por frecuencia. Esas t√©cnicas lo que
permit√≠an era lograr que varios nodos utilicen el medio "de forma
independiente", o sea que la transmisi√≥n de un dispositivo no interfiera con la
de otro.</p>
<p>Ahora vamos a ver otro approach, que es sugerido y generalmente utilizado para
ethernet y en el protocolo de wifi (802.11). La idea es permitir que todos los
dispositivos usen el mismo canal para transferir, y si m√°s adelante hay un
problema (ej 2 quieren transmitir al mismo tiempo) ah√≠ se ve c√≥mo se resuelve.</p>
<p>Y por supuesto se va a buscar minimizar la cantidad de intentos que tiene que
hacer un dispositivo para poder hacer el envio de paquetes deseado y asegurar
fairness.</p>
<p>La tecnolog√≠a que usa Ethernet y otras redes inal√°mbricas (802.11), lleva el
nombre de Carrier Sense, Multiple Access with Collision Detect (CSMA/CD). Es un
protocolo que permite que un conjunto de nodos manden mensajes a trav√©s de un
enlace compartido.</p>
<ul>
<li>El <strong>Carrier Sense</strong> viene por el hecho de que todos los nodos pueden
distinguir en todo momento si un canal est√° libre o en uso.</li>
<li>Por otro lado, el <strong>Collision Detect</strong> viene por el hecho de que el emisor a
medida que transmite sensa el canal y puede darse cuenta de si hubo una
colisi√≥n en la transmisi√≥n con otro nodo.</li>
</ul>
<p>La realidad es que hoy en d√≠a la mayor√≠a de las conexiones cableadas son punto
a punto (o sea el enlace es propio de cada par de nodos). Y la parte de
multiplexaci√≥n la resuelven los switches. Es por eso que hoy en d√≠a no est√° tan
presente el protocolo... redes cableadas.</p>
<p>Por otro lado las redes inal√°mbricas hoy en d√≠a son la norma en muchos entornos
con lo cual el uso de CSMA/CD retoma relevancia.</p>
<p><img src="./img/csma_cd_meme.png" alt="" /></p>
<div id="admonition-dominio-de-colisi√≥n" class="admonition admonish-info">
<div class="admonition-title">
<p>Dominio de Colisi√≥n</p>
<p><a class="admonition-anchor-link" href="unidad_3.html#admonition-dominio-de-colisi√≥n"></a></p>
</div>
<div>
<p>Llamamos <strong>Dominio de Colisi√≥n</strong> al conjunto de los nodos que pueden generar
una colisi√≥n en el medio al intentar transmitir (no est√°n incluidas los nodos
separados por medio de un switch).</p>
</div>
</div>
<h2 id="csmacd"><a class="header" href="#csmacd">CSMA/CD</a></h2>
<p>Vamos a ver el caso de acceso m√∫ltiple en cable ethernet ya que si bien es algo
anecd√≥tico hoy en d√≠a, los mismos principios se pueden aplicar a nuevas
tecnolog√≠as.</p>
<p>Para empezar hablemos un toque de Ethernet:</p>
<ul>
<li>Admite tramos de hasta 500m (no m√°s para evitar atenuaci√≥n de la se√±al).</li>
<li>Admite m√°ximo hasta 4 repetidores</li>
<li>Requiere como m√≠nimo 2,5 metros entre host y host.</li>
<li>Las transmisiones son broadcasteadas a lo largo del cable (y a trav√©s de
repetidores)</li>
</ul>
<p>Adem√°s, un frame de Ethernet contiene los siguientes campos (segun el est√°ndar 802.3):</p>
<p><img src="./img/eth_frame.png" alt="" /></p>
<ul>
<li>Primero tiene un pre√°mbulo de 64 bits, es una secuencia de 0's y 1's
alternada que le permite al receptor sincronizarse con la se√±al.</li>
<li>Despu√©s le siguen las direcciones de destino y fuente respectivamente que son
direcciones de 48 bits.
<ul>
<li>las direcciones son "√∫nicas" y vienen grabadas en la rom de los
adaptadores de red</li>
<li>El adaptador de red sensa el canal y si ve un frame cuyo campo de
destinatario es su direcci√≥n entonces le deriva el frame al host. Hace lo
mismo si el frame tiene la direcci√≥n de broadcast.</li>
</ul>
</li>
<li>Despu√©s sigue el campo del tipo, que indica a cu√°l protocolo de m√°s alto
nivel se le enviar√≠a el frame.</li>
<li>Luego el body del frame tiene la data en si a enviar. Un detalle no menor es
que un frame puede contener hasta 1500 bytes de datos, y tiene que tener por
lo menos 46 bytes de datos (esto √∫ltimo es necesario para tener tiempo
suficiente de detectar una colisi√≥n) por lo que en caso de no tener
suficientes datos se le agrega algo de padding.</li>
<li>Por √∫ltimo un campo CRC para chequeo de errores</li>
</ul>
<p>Un peque√±o detalle es que para el host el frame de ethernet en realidad no
tiene ni el pre√°mbulo ni el CRC, el adaptador de red es el que se encarga de
agregar esos campos extra.</p>
<p>El algoritmo que sigue un transmisor que implementa CSMA/CD se puede resumir con el siguiente diagrama de estados:</p>
<p><img src="./img/csma_cd_state_diagram.png" alt="" /></p>
<ul>
<li>El transmisor siempre que le llega un frame nuevo va a intentar transmitir
<ul>
<li>Si el canal est√° libre transmite de una</li>
<li>Si el canal est√° ocupado, espera a que se libere
<ul>
<li>Ni bien se libera, el transmisor va a intentar enviar</li>
</ul>
</li>
</ul>
</li>
<li>Si est√° transmitiendo, pueden pasar 1 de 2 cosas:
<ul>
<li>Es el √∫nico dispositivo usando el canal y el frame se env√≠a correctamente
y sin problemas</li>
<li>Mientras est√° enviando, otro dispositivo tambi√©n decide enviar un frame,
generando lo que se conoce como una <strong>colisi√≥n</strong>. Para eso el transmisor
sensa el medio y si detecta un voltage anormal entonces eso es a causa de
la colisi√≥n
<ul>
<li>Cuando detecta una colisi√≥n frena la transmisi√≥n actual y env√≠a una
<strong>secuencia de jamming</strong> de 32 bits (por lo general es una tira de
1's y listo). El objetivo de dicha secuencia es hacer que el receptor
deje de escuchar la se√±al.
<ul>
<li>Eventualmente el otro emisor tambi√©n va a detectar la colisi√≥n y
va a enviar su propia secuencia de jamming.</li>
</ul>
</li>
<li>Una vez que se detecta la colisi√≥n y se env√≠a la secuencia de
jamming, se aplica una pol√≠tica de <strong>exponential backoff</strong>. Eso es
esperar un cierto tiempo antes de enviar. Si se vuelve a dar una
colisi√≥n, esperar el doble y as√≠ hasta que se haga efectiva o se
supere un l√≠mite predefinido (en general es de 16 intentos), en cuyo
caso el adaptador avisa al host que la transmisi√≥n fall√≥.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div id="admonition-exponential-backoff" class="admonition admonish-info">
<div class="admonition-title">
<p>Exponential Backoff</p>
<p><a class="admonition-anchor-link" href="unidad_3.html#admonition-exponential-backoff"></a></p>
</div>
<div>
<p>Para ser un poco m√°s espec√≠fico, la idea en el exponential backoff es dividir
el tiempo en slots entre 0 y \(2^k - 1\), siendo \(k\) la cantidad de
intentos. Se elige uno de los slots al azar y eso representa la cantidad de
slots que se espera. Un slot representa 51,2 \(\mu\)s que es el tiempo
necesario para transferir el frame m√°s chico.</p>
</div>
</div>
<p>Ahora que conocemos el algoritmo, tiene m√°s sentido el motivo por el cu√°l
necesitamos tener al menos 46 bytes de datos a enviar. Esto es porque incluso
en el caso en el que est√©n los dos hosts lo m√°s alejados posible (2500 metros
usando 4 repetidores), el Round Trip Delay es de al rededor de 51,2 \(\mu\)s
que en una conexi√≥n de 10Mbps equivale a 512 bits. De esta forma, si nuestra
frame tiene al menos 512 bits si o si uno de los dos emisores va a detectar la
colisi√≥n antes de terminar de enviar su frame.</p>
<div id="admonition-transmisores-p-persistentes" class="admonition admonish-info">
<div class="admonition-title">
<p>Transmisores <em>p</em>-persistentes</p>
<p><a class="admonition-anchor-link" href="unidad_3.html#admonition-transmisores-p-persistentes"></a></p>
</div>
<div>
<p>Ethernet se dice que es un protocolo 1-persistente porque siempre que sensa el
medio y est√° libre va a intentar enviar. Este es un caso particular de lo que
se conoce como transmisores <em>p</em>-persistentes, en donde se transmite con
probabilidad <em>p</em> una vez que se libera el medio.</p>
</div>
</div>
<p>Una √∫ltima observaci√≥n es que en este algoritmo se contempla que s√≥lo se puede
leer <em>o</em> escribir en el canal, pero no los 2 al mismo tiempo. Eso se conoce
como un algoritmo de <strong>half-duplex</strong>. No confundir esto con la clasificaci√≥n de
canales. El canal puede ser full duplex (se puede escuchar y enviar al mismo
tiempo) mientras que el algoritmo es half duplex.</p>
<p>Recomiendo tambi√©n pegarle una chusmeada a <a href="https://cs.newpaltz.edu/~easwarac/CCN/Week13/CSMA.pdf">esta explicaci√≥n</a> de CSMA/CD.</p>
<h3 id="midiendo-performance-de-csma"><a class="header" href="#midiendo-performance-de-csma">Midiendo performance de CSMA</a></h3>
<p>Sean \(S\) la <strong>carga ofrecida</strong> (nro de intentos de transmisi√≥n por unidad
de tiempo, o sea cu√°nto tengo que usar del medio para transmitir) y \(G\) el
<strong>goodput</strong> (proporci√≥n de transmisiones exitosas por unidad de tiempo),
entonces:</p>
<p>$$
S = G * (1 - P_{colision})
$$</p>
<p>Podemos graficar la relaci√≥n entre la carga, el goodput y la variante de CSMA:</p>
<p><img src="./img/link_performance.png#center" alt="" /></p>
<ul>
<li>Aloha es otro protocolo que consiste en lo que vimos antes. Enviar un mensaje
y si no me llega un ACK de dicho mensaje re-enviar. (esto no descarta
totalmente ese mecanismo para asegurar confiabilidad y control de errores
porque como verems m√°s adelante si se usa en protocolos de m√°s alto nivel)
<ul>
<li>Slotted aloha es lo mismo pero la emisi√≥n se da en "slots discretos"</li>
</ul>
</li>
<li>CSMA es f√°cil de implementar pero tiene mala perf en la pr√°ctica a medida que
aumenta la carga. (en estudios se valid√≥ que a partir de 30% de carga aprox
ya se degrada mucho)</li>
<li>En el gr√°fico se hace menci√≥n de non-persistent CSMA. La diferencia entre
este y 1p-CSMA/CD es que 1p-CSMA/CD transmite ni bien encuentra el canal
libre. En cambio el non persistent sensa el canal y si est√° en uso espera una
cantidad fija de tiempo (no transmite ni bien se libera). Si bien reduce las
changes de colisi√≥n tambi√©n cae el throughput. Dicho eso reacciona mejor a la
relaci√≥n entre carga y goodput.</li>
<li>Se hace obvia la relaci√≥n entre el delay hasta poder transmitir (si espero
m√°s entre cada transmisi√≥n) y el goodput, y c√≥mo esto afecta al throughput
final.</li>
</ul>
<hr />
<p>TODO: Resumir diapos 20-24 inclusive (no encuentro referencia en la docu)</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-4---nivel-de-red"><a class="header" href="#unidad-4---nivel-de-red">Unidad 4 - Nivel de Red</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-5---ruteo"><a class="header" href="#unidad-5---ruteo">Unidad 5 - Ruteo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-6---nivel-de-transporte"><a class="header" href="#unidad-6---nivel-de-transporte">Unidad 6 - Nivel de Transporte</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-7---el-problema-de-congesti√≥n"><a class="header" href="#unidad-7---el-problema-de-congesti√≥n">Unidad 7 - El problema de Congesti√≥n</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-8---nivel-de-aplicaci√≥n"><a class="header" href="#unidad-8---nivel-de-aplicaci√≥n">Unidad 8 - Nivel de Aplicaci√≥n</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-9---seguridad"><a class="header" href="#unidad-9---seguridad">Unidad 9 - Seguridad</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliograf√≠a"><a class="header" href="#bibliograf√≠a">Bibliograf√≠a</a></h1>
<p>Libro de Cabecera de la materia:</p>
<ul>
<li>Larry L. Peterson and Bruce S. Davie. 2011. Computer Networks, Fifth edition: A Systems Approach. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.</li>
</ul>
<p>Libro complementario que no vimos en la materia pero me pareci√≥ did√°ctico:</p>
<ul>
<li><a href="https://catnip.article19.org/">How The internet really works - An Illustrated Guide to protocols, privacy, censorship, and governance</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
